/home/emily/repos/Empirical_MoreTests/coverage_source/base/Ptr.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file Ptr.h
    7|       | *  @brief A wrapper for pointers that does careful memory tracking (but only in debug mode).
    8|       | *  @note Status: BETA
    9|       | *
   10|       | *  Ptr objects behave as normal pointers under most conditions.  However, if a program is
   11|       | *  compiled with EMP_TRACK_MEM set, then these pointers perform extra tests to ensure that
   12|       | *  they point to valid memory and that memory is freed before pointers are released.
   13|       | *
   14|       | *  If you trip an assert, you can re-do the run a track a specific pointer by defining
   15|       | *  EMP_ABORT_PTR_NEW or EMP_ABORT_PTR_DELETE to the ID of the pointer in question.  This will
   16|       | *  allow you to track the pointer more easily in a debugger.
   17|       | *
   18|       | *  @todo Track information about emp::vector and emp::array objects to make sure we don't
   19|       | *    point directly into them? (A resize() could make such pointers invalid!) Or better, warn
   20|       | *    it vector memory could have moved.
   21|       | *  @todo Get working with threads
   22|       | */
   23|       |
   24|       |#ifndef EMP_PTR_H
   25|       |#define EMP_PTR_H
   26|       |
   27|       |#include <unordered_map>
   28|       |
   29|       |#include "assert.h"
   30|       |#include "vector.h"
   31|       |
   32|       |namespace emp {
   33|       |
   34|       |  namespace internal {
   35|       |    /// An anonymous log2 calculator for hashing below.
   36|      0|    static constexpr size_t Log2(size_t x) { return x <= 1 ? 0 : (Log2(x/2) + 1); }
   37|       |
   38|       |    static bool ptr_debug = false;
   39|       |  }
   40|      0|  void SetPtrDebug(bool _d = true) { internal::ptr_debug = _d; }
   41|      0|  bool GetPtrDebug() { return internal::ptr_debug; }
   42|       |
   43|       |  enum class PtrStatus { DELETED=0, ACTIVE, ARRAY };
   44|       |
   45|       |  class PtrInfo {
   46|       |  private:
   47|       |    const void * ptr;   ///< Which pointer are we keeping data on?
   48|       |    int count;          ///< How many of this pointer do we have?
   49|       |    PtrStatus status;   ///< Has this pointer been deleted? (i.e., we should no longer access it!)
   50|       |    size_t array_bytes; ///< How big is the array pointed to (in bytes)?
   51|       |
   52|       |  public:
   53|      4|    PtrInfo(const void * _ptr) : ptr(_ptr), count(1), status(PtrStatus::ACTIVE), array_bytes(0) {
   54|      4|      if (internal::ptr_debug) std::cout << "Created info for pointer: " << ptr << std::endl;
   55|      4|    }
   56|       |    PtrInfo(const void * _ptr, size_t _array_bytes)
   57|       |      : ptr(_ptr), count(1), status(PtrStatus::ARRAY), array_bytes(_array_bytes)
   58|      0|    {
   59|      0|      emp_assert(_array_bytes >= 1);
   60|      0|      if (internal::ptr_debug) {
   61|      0|        std::cout << "Created info for array pointer (bytes=" << array_bytes << "): "
   62|      0|                  << ptr << std::endl;
   63|      0|      }
   64|      0|    }
   65|       |    PtrInfo(const PtrInfo &) = default;
   66|       |    PtrInfo(PtrInfo &&) = default;
   67|       |    PtrInfo & operator=(const PtrInfo &) = default;
   68|       |    PtrInfo & operator=(PtrInfo &&) = default;
   69|       |
   70|      7|    ~PtrInfo() {
   71|      7|      if (internal::ptr_debug) std::cout << "Deleted info for pointer " << ptr << std::endl;
   72|      7|    }
   73|       |
   74|       |    /// What pointer does this one hold information about?
   75|      0|    const void * GetPtr() const noexcept { return ptr; }
   76|       |
   77|       |    /// How many Ptr objects point to the associated position?
   78|     12|    int GetCount() const noexcept { return count; }
   79|       |
   80|       |    /// If this ptr is to an array, how many bytes large is the array (may be different from size!)
   81|      0|    size_t GetArrayBytes() const noexcept { return array_bytes; }
   82|       |
   83|       |    /// Is this pointer currently valid to access?
   84|     13|    bool IsActive() const noexcept { return (bool) status; }
   85|       |
   86|       |    /// Is this pointer pointing to an array?
   87|      4|    bool IsArray() const noexcept { return status == PtrStatus::ARRAY; }
   88|       |
   89|       |    /// Denote that this pointer is an array.
   90|      0|    void SetArray(size_t bytes) noexcept { array_bytes = bytes; status = PtrStatus::ARRAY; }
   91|       |
   92|       |    /// Add one more pointer.
   93|     10|    void Inc(size_t id) {
   94|     10|      if (internal::ptr_debug) std::cout << "Inc info for pointer " << ptr << std::endl;
   95|     10|      emp_assert(status != PtrStatus::DELETED, "Incrementing deleted pointer!", id);
   96|     10|      count++;
   97|     10|    }
   98|       |
   99|       |    /// Remove a pointer.
  100|      4|    void Dec(size_t id) {
  101|      4|      if (internal::ptr_debug) std::cout << "Dec info for pointer " << ptr << std::endl;
  102|      4|
  103|      4|      // Make sure that we have more than one copy, -or- we've already deleted this pointer
  104|      4|      emp_assert(count > 1 || status == PtrStatus::DELETED, "Removing last reference to owned Ptr!", id);
  105|      4|      count--;
  106|      4|    }
  107|       |
  108|       |    /// Indicate that the associated position has been deleted.
  109|      4|    void MarkDeleted() {
  110|      4|      if (internal::ptr_debug) std::cout << "Marked deleted for pointer " << ptr << std::endl;
  111|      4|      status = PtrStatus::DELETED;
  112|      4|    }
  113|       |
  114|       |    /// Debug utility to determine if everything looks okay with this pointer's information.
  115|      0|    bool OK() const noexcept {
  116|      0|      if (ptr == nullptr) return false;     // Should not have info for a null pointer.
  117|      0|      if (status == PtrStatus::ARRAY) {
  118|      0|        if (array_bytes == 0) return false; // Arrays cannot be size 0.
  119|      0|        if (count == 0) return false;       // Active arrays must have pointers to them.
  120|      0|      }
  121|      0|      if (status == PtrStatus::ACTIVE) {
  122|      0|        if (array_bytes > 0) return false;  // non-arrays must be array size 0.
  123|      0|        if (count == 0) return false;       // Active pointers must have references to them.
  124|      0|      }
  125|      0|      return true;
  126|      0|    }
  127|       |  };
  128|       |
  129|       |
  130|       |  /// Facilitate tracking of all Ptr objects in this run.
  131|       |  class PtrTracker {
  132|       |  private:
  133|       |    std::unordered_map<const void *, size_t> ptr_id;  ///< Associate raw pointers with unique IDs
  134|       |    emp::vector<PtrInfo> id_info;                     ///< Associate IDs with pointer information.
  135|       |    static constexpr size_t UNTRACKED_ID = (size_t) -1;
  136|       |
  137|       |    // Make PtrTracker a singleton.
  138|      1|    PtrTracker() : ptr_id(), id_info() {
  139|      1|      std::cout << "EMP_TRACK_MEM: Pointer tracking is active!\n";
  140|      1|    }
  141|       |    PtrTracker(const PtrTracker &) = delete;
  142|       |    PtrTracker(PtrTracker &&) = delete;
  143|       |    PtrTracker & operator=(const PtrTracker &) = delete;
  144|       |    PtrTracker & operator=(PtrTracker &&) = delete;
  145|       |
  146|       |  public:
  147|      1|    ~PtrTracker() {
  148|      1|      // Track stats about pointer record.
  149|      1|      size_t total = 0;
  150|      1|      size_t remain = 0;
  151|      1|
  152|      1|      // Scan through live pointers and make sure all have been deleted.
  153|      4|      for (const auto & info : id_info) {
  154|      4|        total++;
  155|      4|        if (info.GetCount()) remain++;
  156|      4|
  157|      4|        emp_assert(info.IsActive() == false, info.GetPtr(), info.GetCount(), info.IsActive());
  158|      4|      }
  159|      1|
  160|      1|      std::cout << "EMP_TRACK_MEM: No memory leaks found!\n "
  161|      1|                << total << " pointers found; "
  162|      1|                << remain << " still exist with a non-null value (but have been properly deleted)"
  163|      1|                << std::endl;
  164|      1|    }
  165|       |
  166|       |    /// Treat this class as a singleton with a single Get() method to retrieve it.
  167|     70|    static PtrTracker & Get() { static PtrTracker tracker; return tracker; }
  168|       |
  169|       |    /// Get the info associated with an existing pointer.
  170|      0|    PtrInfo & GetInfo(const void * ptr) { return id_info[ptr_id[ptr]]; }
  171|      0|    PtrInfo & GetInfo(size_t id) { return id_info[id]; }
  172|       |
  173|       |    /// Determine if a pointer is being tracked.
  174|      4|    bool HasPtr(const void * ptr) const {
  175|      4|      if (internal::ptr_debug) std::cout << "HasPtr: " << ptr << std::endl;
  176|      4|      return ptr_id.find(ptr) != ptr_id.end();
  177|      4|    }
  178|       |
  179|       |    /// Retrive the ID associated with a pointer.
  180|      0|    size_t GetCurID(const void * ptr) { emp_assert(HasPtr(ptr)); return ptr_id[ptr]; }
  181|       |
  182|       |    /// Lookup how many pointers are being tracked.
  183|      4|    size_t GetNumIDs() const { return id_info.size(); }
  184|       |
  185|       |    /// How big is an array associated with an ID?
  186|      0|    size_t GetArrayBytes(size_t id) const { return id_info[id].GetArrayBytes(); }
  187|       |
  188|       |    /// Check if an ID is for a pointer that has been deleted.
  189|     15|    bool IsDeleted(size_t id) const {
  190|     15|      if (id == UNTRACKED_ID) return false;   // Not tracked!
  191|      5|      if (internal::ptr_debug) std::cout << "IsDeleted: " << id << std::endl;
  192|      5|      return !id_info[id].IsActive();
  193|      5|    }
  194|       |
  195|       |    /// Is a pointer active and ready to be used?
  196|      4|    bool IsActive(const void * ptr) {
  197|      4|      if (internal::ptr_debug) std::cout << "IsActive: " << ptr << std::endl;
  198|      4|      if (ptr_id.find(ptr) == ptr_id.end()) return false; // Not in database.
  199|      0|      return GetInfo(ptr).IsActive();
  200|      0|    }
  201|       |
  202|       |    /// Is a pointer id associated with a pointer that's active and ready to be used?
  203|      0|    bool IsActiveID(size_t id) {
  204|      0|      if (id == UNTRACKED_ID) return false;
  205|      0|      if (id >= id_info.size()) return false;
  206|      0|      return id_info[id].IsActive();
  207|      0|    }
  208|       |
  209|       |    /// Is an ID associated with an array?
  210|      4|    bool IsArrayID(size_t id) {
  211|      4|      if (internal::ptr_debug) std::cout << "IsArrayID: " << id << std::endl;
  212|      4|      return id_info[id].IsArray();
  213|      4|    }
  214|       |
  215|       |    /// How many Ptr objects are associated with an ID?
  216|      4|    int GetIDCount(size_t id) const {
  217|      4|      if (internal::ptr_debug) std::cout << "Count:  " << id << std::endl;
  218|      4|      return id_info[id].GetCount();
  219|      4|    }
  220|       |
  221|       |    /// This pointer was just created as a Ptr!
  222|      4|    size_t New(const void * ptr) {
  223|      4|      emp_assert(ptr);     // Cannot track a null pointer.
  224|      4|      size_t id = id_info.size();
  225|       |#ifdef EMP_ABORT_PTR_NEW
  226|       |      if (id == EMP_ABORT_PTR_NEW) {
  227|       |        std::cerr << "Aborting at creation of Ptr id " << id << std::endl;
  228|       |        abort();
  229|       |      }
  230|       |#endif
  231|      4|      if (internal::ptr_debug) std::cout << "New:    " << id << " (" << ptr << ")" << std::endl;
  232|      4|      // Make sure pointer is not already stored -OR- hase been deleted (since re-use is possible).
  233|      4|      emp_assert(!HasPtr(ptr) || IsDeleted(GetCurID(ptr)), id);
  234|      4|      id_info.emplace_back(ptr);
  235|      4|      ptr_id[ptr] = id;
  236|      4|      return id;
  237|      4|    }
  238|       |
  239|       |    /// This pointer was just created as a Ptr ARRAY!
  240|      0|    size_t NewArray(const void * ptr, size_t array_bytes) {
  241|      0|      size_t id = New(ptr);  // Build the new pointer.
  242|      0|      if (internal::ptr_debug) std::cout << "  ...Array of size " << array_bytes << std::endl;
  243|      0|      id_info[id].SetArray(array_bytes);
  244|      0|      return id;
  245|      0|    }
  246|       |
  247|       |    /// Increment the nuber of Pointers associated with an ID
  248|     11|    void IncID(size_t id) {
  249|     11|      if (id == UNTRACKED_ID) return;   // Not tracked!
  250|     10|      if (internal::ptr_debug) std::cout << "Inc:    " << id << std::endl;
  251|     10|      id_info[id].Inc(id);
  252|     10|    }
  253|       |
  254|       |    /// Decrement the nuber of Pointers associated with an ID
  255|     20|    void DecID(size_t id) {
  256|     20|      if (id == UNTRACKED_ID) return;   // Not tracked!
  257|      4|      auto & info = id_info[id];
  258|      4|      if (internal::ptr_debug) std::cout << "Dec:    " << id << "(" << info.GetPtr() << ")" << std::endl;
  259|      4|      emp_assert(info.GetCount() > 0, "Decrementing Ptr, but already zero!",
  260|      4|                 id, info.GetPtr(), info.IsActive());
  261|      4|      info.Dec(id);
  262|      4|    }
  263|       |
  264|       |    /// Mark the pointers associated with this ID as deleted.
  265|      4|    void MarkDeleted(size_t id) {
  266|       |#ifdef EMP_ABORT_PTR_DELETE
  267|       |      if (id == EMP_ABORT_PTR_DELETE) {
  268|       |        std::cerr << "Aborting at deletion of Ptr id " << id << std::endl;
  269|       |        abort();
  270|       |      }
  271|       |#endif
  272|      4|      if (internal::ptr_debug) std::cout << "Delete: " << id << std::endl;
  273|      4|      emp_assert(id_info[id].IsActive(), "Deleting same emp::Ptr a second time!", id);
  274|      4|      id_info[id].MarkDeleted();
  275|      4|    }
  276|       |  };
  277|       |
  278|       |
  279|       |//////////////////////////////////
  280|       |//
  281|       |//  --- Ptr implementation ---
  282|       |//
  283|       |//////////////////////////////////
  284|       |
  285|       |#ifdef EMP_TRACK_MEM
  286|       |
  287|       |  namespace {
  288|       |    // @CAO: Build this for real!
  289|      0|    /*_FORCE_COVER_START_*/template <typename FROM, typename TO>
  290|      4|    bool PtrIsConvertable(FROM * ptr) { return true; }/*_FORCE_COVER_END_*/
  291|       |    // emp_assert( (std::is_same<TYPE,T2>() || dynamic_cast<TYPE*>(in_ptr)) );
  292|       |
  293|       |    // Debug information provided for each pointer type.
  294|       |    struct PtrDebug {
  295|       |      size_t current;
  296|       |      size_t total;
  297|      2|      PtrDebug() : current(0), total(0) { ; }
  298|      4|      void AddPtr() { current++; total++; }
  299|      4|      void RemovePtr() { current--; }
  300|       |    };
  301|       |  }
  302|       |
  303|       |  template <typename TYPE>
  304|       |  class Ptr {
  305|       |  public:
  306|       |    TYPE * ptr;                 ///< The raw pointer associated with this Ptr object.
  307|       |    size_t id;                  ///< A unique ID for this pointer type.
  308|       |    using element_type = TYPE;  ///< Type being pointed at.
  309|       |
  310|       |    static constexpr size_t UNTRACKED_ID = (size_t) -1;
  311|       |
  312|      8|    /*_FORCE_COVER_START_*/static PtrDebug & DebugInfo() { static PtrDebug info; return info; }/*_FORCE_COVER_END_*/ // Debug info for each type
  ------------------
  | test_base.cc:_ZN3emp3PtrIiE9DebugInfoEv:
  |  312|      4|    /*_FORCE_COVER_START_*/static PtrDebug & DebugInfo() { static PtrDebug info; return info; }/*_FORCE_COVER_END_*/ // Debug info for each type
  ------------------
  | test_base.cc:_ZN3emp3PtrIcE9DebugInfoEv:
  |  312|      4|    /*_FORCE_COVER_START_*/static PtrDebug & DebugInfo() { static PtrDebug info; return info; }/*_FORCE_COVER_END_*/ // Debug info for each type
  ------------------
  313|     70|    /*_FORCE_COVER_START_*/static PtrTracker & Tracker() { return PtrTracker::Get(); }/*_FORCE_COVER_END_*/  // Single tracker for al Ptr types
  ------------------
  | _ZN3emp3PtrIiE7TrackerEv:
  |  313|     44|    /*_FORCE_COVER_START_*/static PtrTracker & Tracker() { return PtrTracker::Get(); }/*_FORCE_COVER_END_*/  // Single tracker for al Ptr types
  ------------------
  | _ZN3emp3PtrIcE7TrackerEv:
  |  313|     26|    /*_FORCE_COVER_START_*/static PtrTracker & Tracker() { return PtrTracker::Get(); }/*_FORCE_COVER_END_*/  // Single tracker for al Ptr types
  ------------------
  314|       |
  315|       |    /// Construct a null Ptr by default.
  316|      4|    /*_FORCE_COVER_START_*/Ptr() : ptr(nullptr), id(UNTRACKED_ID) {
  317|      4|      if (internal::ptr_debug) std::cout << "null construct: " << ptr << std::endl;
  318|      4|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3PtrIiEC2Ev:
  |  316|      3|    /*_FORCE_COVER_START_*/Ptr() : ptr(nullptr), id(UNTRACKED_ID) {
  |  317|      3|      if (internal::ptr_debug) std::cout << "null construct: " << ptr << std::endl;
  |  318|      3|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3PtrIcEC2Ev:
  |  316|      1|    /*_FORCE_COVER_START_*/Ptr() : ptr(nullptr), id(UNTRACKED_ID) {
  |  317|      1|      if (internal::ptr_debug) std::cout << "null construct: " << ptr << std::endl;
  |  318|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  319|       |
  320|       |    /// Construct using copy constructor
  321|     10|    /*_FORCE_COVER_START_*/Ptr(const Ptr<TYPE> & _in) : ptr(_in.ptr), id(_in.id) {
  322|     10|      if (internal::ptr_debug) std::cout << "copy construct: " << ptr << std::endl;
  323|     10|      Tracker().IncID(id);
  324|     10|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3PtrIiEC2ERKS1_:
  |  321|      1|    /*_FORCE_COVER_START_*/Ptr(const Ptr<TYPE> & _in) : ptr(_in.ptr), id(_in.id) {
  |  322|      1|      if (internal::ptr_debug) std::cout << "copy construct: " << ptr << std::endl;
  |  323|      1|      Tracker().IncID(id);
  |  324|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3PtrIcEC2ERKS1_:
  |  321|      9|    /*_FORCE_COVER_START_*/Ptr(const Ptr<TYPE> & _in) : ptr(_in.ptr), id(_in.id) {
  |  322|      9|      if (internal::ptr_debug) std::cout << "copy construct: " << ptr << std::endl;
  |  323|      9|      Tracker().IncID(id);
  |  324|      9|    }/*_FORCE_COVER_END_*/
  ------------------
  325|       |
  326|       |    /// Construct using move constructor
  327|      6|    /*_FORCE_COVER_START_*/Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr), id(_in.id) {
  328|      6|      if (internal::ptr_debug) std::cout << "move construct: " << ptr << std::endl;
  329|      6|      _in.ptr = nullptr;
  330|      6|      _in.id = UNTRACKED_ID;
  331|      6|      // No IncID or DecID in Tracker since we just move the id.
  332|      6|    }/*_FORCE_COVER_END_*/
  333|       |
  334|       |    /// Construct from a raw pointer of campatable type.
  335|      0|    /*_FORCE_COVER_START_*/template <typename T2>
  336|      0|    /*_FORCE_COVER_START_*/Ptr(T2 * in_ptr, bool track=false) : ptr(in_ptr), id(UNTRACKED_ID)
  337|      4|    {
  338|      4|      if (internal::ptr_debug) std::cout << "raw construct: " << ptr << ". track=" << track << std::endl;
  339|      4|      emp_assert( (PtrIsConvertable<T2, TYPE>(in_ptr)) );
  340|      4|
  341|      4|      // If this pointer is already active, link to it.
  342|      4|      if (Tracker().IsActive(ptr)) {
  343|      0|        id = Tracker().GetCurID(ptr);
  344|      0|        Tracker().IncID(id);
  345|      0|      }
  346|      4|      // If we are not already tracking this pointer, but should be, add it.
  347|      4|      else if (track) {
  348|      1|        id = Tracker().New(ptr);
  349|      1|        DebugInfo().AddPtr();
  350|      1|      }
  351|      4|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  352|       |
  353|       |    /// Construct from a raw pointer of campatable ARRAY type.
  354|      0|    /*_FORCE_COVER_START_*/template <typename T2>
  355|      0|    /*_FORCE_COVER_START_*/Ptr(T2 * _ptr, size_t array_size, bool track) : ptr(_ptr), id(UNTRACKED_ID)
  356|       |    {
  357|      0|      const size_t array_bytes = array_size * sizeof(T2);
  358|      0|      if (internal::ptr_debug) std::cout << "raw ARRAY construct: " << ptr
  359|      0|                               << ". size=" << array_size << "(" << array_bytes
  360|      0|                               << " bytes); track=" << track << std::endl;
  361|      0|      emp_assert( (PtrIsConvertable<T2, TYPE>(_ptr)) );
  362|       |
  363|       |      // If this pointer is already active, link to it.
  364|      0|      if (Tracker().IsActive(ptr)) {
  365|      0|        id = Tracker().GetCurID(ptr);
  366|      0|        Tracker().IncID(id);
  367|      0|        emp_assert(Tracker().GetArrayBytes(id) == array_bytes); // Make sure pointer is consistent.
  368|       |      }
  369|       |      // If we are not already tracking this pointer, but should be, add it.
  370|      0|      else if (track) {
  371|      0|        id = Tracker().NewArray(ptr, array_bytes);
  372|      0|        DebugInfo().AddPtr();
  373|       |      }
  374|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  375|       |
  376|       |    /// Construct from another Ptr<> object of compatable type.
  377|      0|    /*_FORCE_COVER_START_*/template <typename T2>
  378|      0|    /*_FORCE_COVER_START_*/Ptr(Ptr<T2> _in) : ptr(_in.Raw()), id(_in.GetID()) {
  379|      0|      if (internal::ptr_debug) std::cout << "inexact copy construct: " << ptr << std::endl;
  380|      0|      emp_assert( (PtrIsConvertable<T2, TYPE>(_in.Raw())), id );
  381|      0|      Tracker().IncID(id);
  382|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  383|       |
  384|       |    /// Construct from nullptr.
  385|      0|    /*_FORCE_COVER_START_*/Ptr(std::nullptr_t) : Ptr() {
  386|      0|      if (internal::ptr_debug) std::cout << "null construct 2." << std::endl;
  387|       |    }/*_FORCE_COVER_END_*/
  388|       |
  389|       |    /// Destructor.
  390|     14|    /*_FORCE_COVER_START_*/~Ptr() {
  391|     14|      if (internal::ptr_debug) {
  392|      0|        std::cout << "destructing Ptr instance ";
  393|      0|        if (ptr) std::cout << id << " (" << ptr << ")\n";
  394|      0|        else std::cout << "(nullptr)\n";
  395|      0|      }
  396|     14|      Tracker().DecID(id);
  397|     14|    }/*_FORCE_COVER_END_*/
  398|       |
  399|       |    /// Is this Ptr currently nullptr?
  400|      0|    /*_FORCE_COVER_START_*/bool IsNull() const { return ptr == nullptr; }/*_FORCE_COVER_END_*/
  401|       |
  402|       |    /// Convert this Ptr to a raw pointer that isn't going to be tracked.
  403|      0|    /*_FORCE_COVER_START_*/TYPE * Raw() {
  404|      0|      emp_assert(Tracker().IsDeleted(id) == false, "Do not convert deleted Ptr to raw.", id);
  405|      0|      return ptr;
  406|       |    }/*_FORCE_COVER_END_*/
  407|       |
  408|       |    /// Convert this Ptr to a const raw pointer that isn't going to be tracked.
  409|      0|    /*_FORCE_COVER_START_*/const TYPE * const Raw() const {
  410|      0|      emp_assert(Tracker().IsDeleted(id) == false, "Do not convert deleted Ptr to raw.", id);
  411|      0|      return ptr;
  412|       |    }/*_FORCE_COVER_END_*/
  413|       |
  414|       |    /// Cast this Ptr to a different type.
  415|      0|    /*_FORCE_COVER_START_*/template <typename T2> /*_FORCE_COVER_START_*/Ptr<T2> Cast() {
  416|      0|      emp_assert(Tracker().IsDeleted(id) == false, "Do not cast deleted pointers.", id);
  417|      0|      return (T2*) ptr;
  418|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  419|       |
  420|       |    /// Cast this Ptr to a const Ptr of a different type.
  421|      0|    /*_FORCE_COVER_START_*/template <typename T2> /*_FORCE_COVER_START_*/const Ptr<const T2> Cast() const {
  422|      0|      emp_assert(Tracker().IsDeleted(id) == false, "Do not cast deleted pointers.", id);
  423|      0|      return (T2*) ptr;
  424|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  425|       |
  426|       |    /// Dynamically cast this Ptr to another type; throw an assert of the cast fails.
  427|      0|    /*_FORCE_COVER_START_*/template <typename T2> /*_FORCE_COVER_START_*/Ptr<T2> DynamicCast() {
  428|      0|      emp_assert(dynamic_cast<T2*>(ptr) != nullptr);
  429|      0|      emp_assert(Tracker().IsDeleted(id) == false, "Do not cast deleted pointers.", id);
  430|      0|      return (T2*) ptr;
  431|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  432|       |
  433|       |    /// Get the unique ID associated with this pointer.
  434|      0|    /*_FORCE_COVER_START_*/size_t GetID() const { return id; }/*_FORCE_COVER_END_*/
  435|       |
  436|       |    /// Reallocate this Ptr to a newly allocated value using arguments passed in.
  437|      0|    /*_FORCE_COVER_START_*/template <typename... T>
  438|      3|    /*_FORCE_COVER_START_*/void New(T &&... args) {
  439|      3|      Tracker().DecID(id);                            // Remove a pointer to any old memory...
  440|      3|
  441|      3|      ptr = new TYPE(std::forward<T>(args)...); // Special new that uses allocated space.
  442|      3|      // ptr = (TYPE*) malloc (sizeof(TYPE));            // Build a new raw pointer.
  443|      3|      // emp_emscripten_assert(ptr);                     // No exceptions in emscripten; assert alloc!
  444|      3|      // ptr = new (ptr) TYPE(std::forward<T>(args)...); // Special new that uses allocated space.
  445|      3|
  446|      3|      if (internal::ptr_debug) std::cout << "Ptr::New() : " << ptr << std::endl;
  447|      3|      id = Tracker().New(ptr);                        // And track it!
  448|      3|      DebugInfo().AddPtr();
  449|      3|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3PtrIiE3NewIJEEEvDpOT_:
  |  438|      1|    /*_FORCE_COVER_START_*/void New(T &&... args) {
  |  439|      1|      Tracker().DecID(id);                            // Remove a pointer to any old memory...
  |  440|      1|
  |  441|      1|      ptr = new TYPE(std::forward<T>(args)...); // Special new that uses allocated space.
  |  442|      1|      // ptr = (TYPE*) malloc (sizeof(TYPE));            // Build a new raw pointer.
  |  443|      1|      // emp_emscripten_assert(ptr);                     // No exceptions in emscripten; assert alloc!
  |  444|      1|      // ptr = new (ptr) TYPE(std::forward<T>(args)...); // Special new that uses allocated space.
  |  445|      1|
  |  446|      1|      if (internal::ptr_debug) std::cout << "Ptr::New() : " << ptr << std::endl;
  |  447|      1|      id = Tracker().New(ptr);                        // And track it!
  |  448|      1|      DebugInfo().AddPtr();
  |  449|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3PtrIcE3NewIJiEEEvDpOT_:
  |  438|      2|    /*_FORCE_COVER_START_*/void New(T &&... args) {
  |  439|      2|      Tracker().DecID(id);                            // Remove a pointer to any old memory...
  |  440|      2|
  |  441|      2|      ptr = new TYPE(std::forward<T>(args)...); // Special new that uses allocated space.
  |  442|      2|      // ptr = (TYPE*) malloc (sizeof(TYPE));            // Build a new raw pointer.
  |  443|      2|      // emp_emscripten_assert(ptr);                     // No exceptions in emscripten; assert alloc!
  |  444|      2|      // ptr = new (ptr) TYPE(std::forward<T>(args)...); // Special new that uses allocated space.
  |  445|      2|
  |  446|      2|      if (internal::ptr_debug) std::cout << "Ptr::New() : " << ptr << std::endl;
  |  447|      2|      id = Tracker().New(ptr);                        // And track it!
  |  448|      2|      DebugInfo().AddPtr();
  |  449|      2|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  450|       |
  451|       |    /// Reallocate this Ptr to a newly allocated array using the size passed in.
  452|      0|    /*_FORCE_COVER_START_*/template <typename... T>
  453|      0|    /*_FORCE_COVER_START_*/void NewArray(size_t array_size, T &&... args) {
  454|      0|      Tracker().DecID(id);                              // Remove a pointer to any old memory...
  455|       |
  456|       |      // @CAO: This next portion of code is allocating an array of the appropriate type.
  457|       |      //       We are currently using "new", but should shift over to malloc since new throws an
  458|       |      //       exception when there's a problem, which will trigger an abort in Emscripten mode.
  459|       |      //       We'd rather be able to identify a more specific problem.
  460|      0|      ptr = new TYPE[array_size];                     // Build a new raw pointer to an array.
  461|       |      // ptr = (TYPE*) malloc (array_size * sizeof(TYPE)); // Build a new raw pointer.
  462|       |      // emp_emscripten_assert(ptr, array_size);           // No exceptions in emscripten; assert alloc!
  463|       |      // for (size_t i = 0; i < array_size; i++) {
  464|       |      //   new (ptr + i*sizeof(TYPE)) TYPE(args...);
  465|       |      // }
  466|       |
  467|      0|      if (internal::ptr_debug) std::cout << "Ptr::NewArray() : " << ptr << std::endl;
  468|      0|      id = Tracker().NewArray(ptr, array_size * sizeof(TYPE));   // And track it!
  469|      0|      DebugInfo().AddPtr();
  470|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  471|       |
  472|       |    /// Delete this pointer (must NOT be an array).
  473|      4|    /*_FORCE_COVER_START_*/void Delete() {
  474|      4|      emp_assert(id < Tracker().GetNumIDs(), id, "Deleting Ptr that we are not resposible for.");
  475|      4|      emp_assert(ptr, "Deleting null Ptr.");
  476|      4|      emp_assert(Tracker().IsArrayID(id) == false, id, "Trying to delete array pointer as non-array.");
  477|      4|      if (internal::ptr_debug) std::cout << "Ptr::Delete() : " << ptr << std::endl;
  478|      4|      delete ptr;
  479|      4|      Tracker().MarkDeleted(id);
  480|      4|      DebugInfo().RemovePtr();
  481|      4|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3PtrIiE6DeleteEv:
  |  473|      2|    /*_FORCE_COVER_START_*/void Delete() {
  |  474|      2|      emp_assert(id < Tracker().GetNumIDs(), id, "Deleting Ptr that we are not resposible for.");
  |  475|      2|      emp_assert(ptr, "Deleting null Ptr.");
  |  476|      2|      emp_assert(Tracker().IsArrayID(id) == false, id, "Trying to delete array pointer as non-array.");
  |  477|      2|      if (internal::ptr_debug) std::cout << "Ptr::Delete() : " << ptr << std::endl;
  |  478|      2|      delete ptr;
  |  479|      2|      Tracker().MarkDeleted(id);
  |  480|      2|      DebugInfo().RemovePtr();
  |  481|      2|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3PtrIcE6DeleteEv:
  |  473|      2|    /*_FORCE_COVER_START_*/void Delete() {
  |  474|      2|      emp_assert(id < Tracker().GetNumIDs(), id, "Deleting Ptr that we are not resposible for.");
  |  475|      2|      emp_assert(ptr, "Deleting null Ptr.");
  |  476|      2|      emp_assert(Tracker().IsArrayID(id) == false, id, "Trying to delete array pointer as non-array.");
  |  477|      2|      if (internal::ptr_debug) std::cout << "Ptr::Delete() : " << ptr << std::endl;
  |  478|      2|      delete ptr;
  |  479|      2|      Tracker().MarkDeleted(id);
  |  480|      2|      DebugInfo().RemovePtr();
  |  481|      2|    }/*_FORCE_COVER_END_*/
  ------------------
  482|       |
  483|       |    /// Delete this pointer to an array (must be an array).
  484|      0|    /*_FORCE_COVER_START_*/void DeleteArray() {
  485|      0|      emp_assert(id < Tracker().GetNumIDs(), id, "Deleting Ptr that we are not resposible for.");
  486|      0|      emp_assert(ptr, "Deleting null Ptr.");
  487|      0|      emp_assert(Tracker().IsArrayID(id), id, "Trying to delete non-array pointer as array.");
  488|      0|      if (internal::ptr_debug) std::cout << "Ptr::DeleteArray() : " << ptr << std::endl;
  489|      0|      delete [] ptr;
  490|      0|      Tracker().MarkDeleted(id);
  491|      0|      DebugInfo().RemovePtr();
  492|       |    }/*_FORCE_COVER_END_*/
  493|       |
  494|       |    /// Convert this pointer to a hash value.
  495|      0|    /*_FORCE_COVER_START_*/size_t Hash() const {
  496|       |      // Chop off useless bits of pointer...
  497|      0|      static constexpr size_t shift = internal::Log2(1 + sizeof(TYPE));
  498|      0|      return (size_t)(ptr) >> shift;
  499|       |    }/*_FORCE_COVER_END_*/
  500|      0|    struct hash_t { /*_FORCE_COVER_START_*/size_t operator()(const Ptr<TYPE> & t) const { return t.Hash(); }/*_FORCE_COVER_END_*/ };
  501|       |
  502|       |    /// Copy assignment
  503|      1|    /*_FORCE_COVER_START_*/Ptr<TYPE> & operator=(const Ptr<TYPE> & _in) {
  504|      1|      if (internal::ptr_debug) std::cout << "copy assignment" << std::endl;
  505|      1|      emp_assert(Tracker().IsDeleted(_in.id) == false, _in.id, "Do not copy deleted pointers.");
  506|      1|      if (id != _in.id) {        // Assignments only need to happen if ptrs are different.
  507|      1|        Tracker().DecID(id);
  508|      1|        ptr = _in.ptr;
  509|      1|        id = _in.id;
  510|      1|        Tracker().IncID(id);
  511|      1|      }
  512|      1|      return *this;
  513|      1|    }/*_FORCE_COVER_END_*/
  514|       |
  515|       |    /// Move assignment
  516|      2|    /*_FORCE_COVER_START_*/Ptr<TYPE> & operator=(Ptr<TYPE> && _in) {
  517|      2|      if (internal::ptr_debug) std::cout << "move assignment: " << _in.ptr << std::endl;
  518|      2|      emp_assert(Tracker().IsDeleted(_in.id) == false, _in.id, "Do not move deleted pointers.");
  519|      2|      if (ptr != _in.ptr) {
  520|      2|        Tracker().DecID(id);   // Decrement references to former pointer at this position.
  521|      2|        ptr = _in.ptr;
  522|      2|        id = _in.id;
  523|      2|        _in.ptr = nullptr;
  524|      2|        _in.id = UNTRACKED_ID;
  525|      2|      }
  526|      2|      return *this;
  527|      2|    }/*_FORCE_COVER_END_*/
  528|       |
  529|       |    /// Assign to a raw pointer of the correct type; if this is already tracked, hooked in
  530|       |    /// correctly, otherwise don't track.
  531|      0|    /*_FORCE_COVER_START_*/template <typename T2>
  532|      0|    /*_FORCE_COVER_START_*/Ptr<TYPE> & operator=(T2 * _in) {
  533|      0|      if (internal::ptr_debug) std::cout << "raw assignment" << std::endl;
  534|      0|      emp_assert( (PtrIsConvertable<T2, TYPE>(_in)) );
  535|       |
  536|      0|      Tracker().DecID(id);    // Decrement references to former pointer at this position.
  537|      0|      ptr = _in;              // Update to new pointer.
  538|       |
  539|       |      // If this pointer is already active, link to it.
  540|      0|      if (Tracker().IsActive(ptr)) {
  541|      0|        id = Tracker().GetCurID(ptr);
  542|      0|        Tracker().IncID(id);
  543|       |      }
  544|       |      // Otherwise, since this ptr was passed in as a raw pointer, we do not manage it.
  545|      0|      else {
  546|      0|        id = UNTRACKED_ID;
  547|       |      }
  548|       |
  549|      0|      return *this;
  550|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  551|       |
  552|       |    /// Assign to a convertable Ptr
  553|      0|    /*_FORCE_COVER_START_*/template <typename T2>
  554|      0|    /*_FORCE_COVER_START_*/Ptr<TYPE> & operator=(Ptr<T2> _in) {
  555|      0|      if (internal::ptr_debug) std::cout << "convert-copy assignment" << std::endl;
  556|      0|      emp_assert( (PtrIsConvertable<T2, TYPE>(_in.Raw())), _in.id );
  557|      0|      emp_assert(Tracker().IsDeleted(_in.id) == false, _in.id, "Do not copy deleted pointers.");
  558|      0|      Tracker().DecID(id);
  559|      0|      ptr = _in.Raw();
  560|      0|      id = _in.GetID();
  561|      0|      Tracker().IncID(id);
  562|      0|      return *this;
  563|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  564|       |
  565|       |    /// Dereference a pointer.
  566|     12|    /*_FORCE_COVER_START_*/TYPE & operator*() {
  567|     12|      // Make sure a pointer is active and non-null before we dereference it.
  568|     12|      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  569|     12|      emp_assert(ptr != nullptr, "Do not dereference a null pointer!");
  570|     12|      return *ptr;
  571|     12|    }/*_FORCE_COVER_END_*/
  572|       |
  573|       |    /// Dereference a pointer to a const type.
  574|      0|    /*_FORCE_COVER_START_*/const TYPE & operator*() const {
  575|       |      // Make sure a pointer is active before we dereference it.
  576|      0|      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  577|      0|      emp_assert(ptr != nullptr, "Do not dereference a null pointer!");
  578|      0|      return *ptr;
  579|       |    }/*_FORCE_COVER_END_*/
  580|       |
  581|       |    /// Follow a pointer.
  582|      0|    /*_FORCE_COVER_START_*/TYPE * operator->() {
  583|       |      // Make sure a pointer is active before we follow it.
  584|      0|      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  585|      0|      emp_assert(ptr != nullptr, "Do not follow a null pointer!");
  586|      0|      return ptr;
  587|       |    }/*_FORCE_COVER_END_*/
  588|       |
  589|       |    /// Follow a pointer to a const target.
  590|      0|    /*_FORCE_COVER_START_*/TYPE * const operator->() const {
  591|       |      // Make sure a pointer is active before we follow it.
  592|      0|      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  593|      0|      emp_assert(ptr != nullptr, "Do not follow a null pointer!");
  594|      0|      return ptr;
  595|       |    }/*_FORCE_COVER_END_*/
  596|       |
  597|       |    /// Indexing into array
  598|      0|    /*_FORCE_COVER_START_*/TYPE & operator[](size_t pos) {
  599|      0|      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  600|      0|      emp_assert(Tracker().IsArrayID(id), "Only arrays can be indexed into.", id);
  601|      0|      emp_assert(Tracker().GetArrayBytes(id) > (pos*sizeof(TYPE)),
  602|      0|        "Indexing out of range.", id, ptr, pos, sizeof(TYPE), Tracker().GetArrayBytes(id));
  603|      0|      emp_assert(ptr != nullptr, "Do not follow a null pointer!");
  604|      0|      return ptr[pos];
  605|       |    }/*_FORCE_COVER_END_*/
  606|       |
  607|       |    /// Indexing into const array
  608|      0|    /*_FORCE_COVER_START_*/const TYPE & operator[](size_t pos) const {
  609|      0|      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  610|      0|      emp_assert(Tracker().IsArrayID(id), "Only arrays can be indexed into.", id);
  611|      0|      emp_assert(Tracker().GetArrayBytes(id) > (pos*sizeof(TYPE)),
  612|      0|        "Indexing out of range.", id, ptr, pos, sizeof(TYPE), Tracker().GetArrayBytes(id));
  613|      0|      emp_assert(ptr != nullptr, "Do not follow a null pointer!");
  614|      0|      return ptr[pos];
  615|       |    }/*_FORCE_COVER_END_*/
  616|       |
  617|       |    /// Auto-case to raw pointer type.
  618|      0|    /*_FORCE_COVER_START_*/operator TYPE *() {
  619|       |      // Make sure a pointer is active before we convert it.
  620|      0|      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  621|       |
  622|       |      // We should not automatically convert managed pointers to raw pointers; use .Raw()
  623|      0|      emp_assert(id == UNTRACKED_ID /*, typeid(TYPE).name() */, id);
  624|      0|      return ptr;
  625|       |    }/*_FORCE_COVER_END_*/
  626|       |
  627|       |    /// Does this pointer exist?
  628|      0|    /*_FORCE_COVER_START_*/operator bool() { return ptr != nullptr; }/*_FORCE_COVER_END_*/
  629|       |
  630|       |    /// Does this const pointer exist?
  631|      0|    /*_FORCE_COVER_START_*/operator bool() const { return ptr != nullptr; }/*_FORCE_COVER_END_*/
  632|       |
  633|       |    /// Does this Ptr point to the same memory position?
  634|      0|    /*_FORCE_COVER_START_*/bool operator==(const Ptr<TYPE> & in_ptr) const { return ptr == in_ptr.ptr; }/*_FORCE_COVER_END_*/
  635|       |
  636|       |    /// Does this Ptr point to different memory positions?
  637|      0|    /*_FORCE_COVER_START_*/bool operator!=(const Ptr<TYPE> & in_ptr) const { return ptr != in_ptr.ptr; }/*_FORCE_COVER_END_*/
  638|       |
  639|       |    /// Does this Ptr point to a memory position before another?
  640|      0|    /*_FORCE_COVER_START_*/bool operator<(const Ptr<TYPE> & in_ptr)  const { return ptr < in_ptr.ptr; }/*_FORCE_COVER_END_*/
  641|       |
  642|       |    /// Does this Ptr point to a memory position before or equal to another?
  643|      0|    /*_FORCE_COVER_START_*/bool operator<=(const Ptr<TYPE> & in_ptr) const { return ptr <= in_ptr.ptr; }/*_FORCE_COVER_END_*/
  644|       |
  645|       |    /// Does this Ptr point to a memory position after another?
  646|      0|    /*_FORCE_COVER_START_*/bool operator>(const Ptr<TYPE> & in_ptr)  const { return ptr > in_ptr.ptr; }/*_FORCE_COVER_END_*/
  647|       |
  648|       |    /// Does this Ptr point to a memory position after or equal to another?
  649|      0|    /*_FORCE_COVER_START_*/bool operator>=(const Ptr<TYPE> & in_ptr) const { return ptr >= in_ptr.ptr; }/*_FORCE_COVER_END_*/
  650|       |
  651|       |
  652|       |    /// Does this Ptr point to the same memory position as a raw pointer?
  653|      0|    /*_FORCE_COVER_START_*/bool operator==(const TYPE * in_ptr) const { return ptr == in_ptr; }/*_FORCE_COVER_END_*/
  654|       |
  655|       |    /// Does this Ptr point to different memory positions as a raw pointer?
  656|      0|    /*_FORCE_COVER_START_*/bool operator!=(const TYPE * in_ptr) const { return ptr != in_ptr; }/*_FORCE_COVER_END_*/
  657|       |
  658|       |    /// Does this Ptr point to a memory position before a raw pointer?
  659|      0|    /*_FORCE_COVER_START_*/bool operator<(const TYPE * in_ptr)  const { return ptr < in_ptr; }/*_FORCE_COVER_END_*/
  660|       |
  661|       |    /// Does this Ptr point to a memory position before or equal to a raw pointer?
  662|      0|    /*_FORCE_COVER_START_*/bool operator<=(const TYPE * in_ptr) const { return ptr <= in_ptr; }/*_FORCE_COVER_END_*/
  663|       |
  664|       |    /// Does this Ptr point to a memory position after a raw pointer?
  665|      0|    /*_FORCE_COVER_START_*/bool operator>(const TYPE * in_ptr)  const { return ptr > in_ptr; }/*_FORCE_COVER_END_*/
  666|       |
  667|       |    /// Does this Ptr point to a memory position after or equal to a raw pointer?
  668|      0|    /*_FORCE_COVER_START_*/bool operator>=(const TYPE * in_ptr) const { return ptr >= in_ptr; }/*_FORCE_COVER_END_*/
  669|       |
  670|       |
  671|       |    /// Some debug testing functions
  672|      4|    /*_FORCE_COVER_START_*/int DebugGetCount() const { return Tracker().GetIDCount(id); }/*_FORCE_COVER_END_*/
  673|      0|    /*_FORCE_COVER_START_*/bool DebugIsArray() const { return Tracker().IsArrayID(id); }/*_FORCE_COVER_END_*/
  674|      0|    /*_FORCE_COVER_START_*/size_t DebugGetArrayBytes() const { return Tracker().GetArrayBytes(id); }/*_FORCE_COVER_END_*/
  675|      0|    /*_FORCE_COVER_START_*/bool DebugIsActive() const { return Tracker().IsActiveID(id); }/*_FORCE_COVER_END_*/
  676|       |
  677|      0|    /*_FORCE_COVER_START_*/bool OK() const {
  678|       |      // Untracked ID's should not have pointers in the Tracker.
  679|      0|      if (id == UNTRACKED_ID) return !Tracker().HasPtr(ptr);
  680|       |
  681|       |      // Make sure this pointer is linked to the correct info.
  682|      0|      if (Tracker().GetInfo(id).GetPtr() != ptr) return false;
  683|       |
  684|       |      // And make sure that info itself is okay.
  685|      0|      return Tracker().GetInfo(id).OK();
  686|       |    }/*_FORCE_COVER_END_*/
  687|       |
  688|       |    // Prevent use of new and delete on Ptr
  689|       |    // static void* operator new(std::size_t) noexcept {
  690|       |    //   emp_assert(false, "No Ptr::operator new; use emp::NewPtr for clarity.");
  691|       |    //   return nullptr;
  692|       |    // }
  693|       |    // static void* operator new[](std::size_t sz) noexcept {
  694|       |    //   emp_assert(false, "No Ptr::operator new[]; use emp::NewPtrArray for clarity.");
  695|       |    //   return nullptr;
  696|       |    // }
  697|       |    //
  698|       |    // static void operator delete(void* ptr, std::size_t sz) {
  699|       |    //   emp_assert(false, "No Ptr::operator delete; use Delete() member function for clarity.");
  700|       |    // }
  701|       |    // static void operator delete[](void* ptr, std::size_t sz) {
  702|       |    //   emp_assert(false, "No Ptr::operator delete[]; use DeleteArray() member function for clarity.");
  703|       |    // }
  704|       |
  705|       |  };
  706|       |
  707|       |#else
  708|       |
  709|       |
  710|       |  template <typename TYPE>
  711|       |  class Ptr {
  712|       |  private:
  713|       |    TYPE * ptr;
  714|       |
  715|       |  public:
  716|       |    using element_type = TYPE;
  717|       |
  718|       |    Ptr() : ptr(nullptr) {}                                              ///< Default constructor
  719|       |    Ptr(const Ptr<TYPE> & _in) : ptr(_in.ptr) {}                         ///< Copy constructor
  720|       |    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  721|       |    template <typename T2> Ptr(T2 * in_ptr, bool=false) : ptr(in_ptr) {} ///< Construct from raw ptr
  722|       |    template <typename T2> Ptr(T2 * _ptr, size_t, bool) : ptr(_ptr) {}   ///< Construct from array
  723|       |    template <typename T2> Ptr(Ptr<T2> _in) : ptr(_in.Raw()) {}          ///< From compatible Ptr
  724|       |    Ptr(std::nullptr_t) : Ptr() {}                                       ///< From nullptr
  725|       |    ~Ptr() { ; }                                                         ///< Destructor
  726|       |
  727|       |    bool IsNull() const { return ptr == nullptr; }
  728|       |    TYPE * Raw() { return ptr; }
  729|       |    const TYPE * const Raw() const { return ptr; }
  730|       |    template <typename T2> Ptr<T2> Cast() { return (T2*) ptr; }
  731|       |    template <typename T2> const Ptr<const T2> Cast() const { return (T2*) ptr; }
  732|       |    template <typename T2> Ptr<T2> DynamicCast() { return dynamic_cast<T2*>(ptr); }
  733|       |
  734|       |    template <typename... T>
  735|       |    void New(T &&... args) { ptr = new TYPE(std::forward<T>(args)...); }  // New raw pointer.
  736|       |    void NewArray(size_t array_size) { ptr = new TYPE[array_size]; }
  737|       |    void Delete() { delete ptr; }
  738|       |    void DeleteArray() { delete [] ptr; }
  739|       |
  740|       |    size_t Hash() const {
  741|       |      static constexpr size_t shift = internal::Log2(1 + sizeof(TYPE));  // Chop off useless bits...
  742|       |      return (size_t)(ptr) >> shift;
  743|       |    }
  744|       |    struct hash_t { size_t operator()(const Ptr<TYPE> & t) const { return t.Hash(); } };
  745|       |
  746|       |    // Copy/Move assignments
  747|       |    Ptr<TYPE> & operator=(const Ptr<TYPE> & _in) { ptr = _in.ptr; return *this; }
  748|       |    Ptr<TYPE> & operator=(Ptr<TYPE> && _in) { ptr = _in.ptr; _in.ptr = nullptr; return *this; }
  749|       |
  750|       |    // Assign to compatible Ptr or raw (non-managed) pointer.
  751|       |    template <typename T2> Ptr<TYPE> & operator=(T2 * _in) { ptr = _in; return *this; }
  752|       |    template <typename T2> Ptr<TYPE> & operator=(Ptr<T2> _in) { ptr = _in.Raw(); return *this; }
  753|       |
  754|       |    // Dereference a pointer.
  755|       |    TYPE & operator*() { return *ptr; }
  756|       |    const TYPE & operator*() const { return *ptr; }
  757|       |
  758|       |    // Follow a pointer.
  759|       |    TYPE * operator->() { return ptr; }
  760|       |    TYPE * const operator->() const { return ptr; }
  761|       |
  762|       |    // Indexing into array
  763|       |    TYPE & operator[](size_t pos) { return ptr[pos]; }
  764|       |    const TYPE & operator[](size_t pos) const { return ptr[pos]; }
  765|       |
  766|       |    // Auto-case to raw pointer type.
  767|       |    operator TYPE *() { return ptr; }
  768|       |
  769|       |    operator bool() { return ptr != nullptr; }
  770|       |    operator bool() const { return ptr != nullptr; }
  771|       |
  772|       |    // Comparisons to other Ptr objects
  773|       |    bool operator==(const Ptr<TYPE> & in_ptr) const { return ptr == in_ptr.ptr; }
  774|       |    bool operator!=(const Ptr<TYPE> & in_ptr) const { return ptr != in_ptr.ptr; }
  775|       |    bool operator<(const Ptr<TYPE> & in_ptr)  const { return ptr < in_ptr.ptr; }
  776|       |    bool operator<=(const Ptr<TYPE> & in_ptr) const { return ptr <= in_ptr.ptr; }
  777|       |    bool operator>(const Ptr<TYPE> & in_ptr)  const { return ptr > in_ptr.ptr; }
  778|       |    bool operator>=(const Ptr<TYPE> & in_ptr) const { return ptr >= in_ptr.ptr; }
  779|       |
  780|       |    // Comparisons to raw pointers.
  781|       |    bool operator==(const TYPE * in_ptr) const { return ptr == in_ptr; }
  782|       |    bool operator!=(const TYPE * in_ptr) const { return ptr != in_ptr; }
  783|       |    bool operator<(const TYPE * in_ptr)  const { return ptr < in_ptr; }
  784|       |    bool operator<=(const TYPE * in_ptr) const { return ptr <= in_ptr; }
  785|       |    bool operator>(const TYPE * in_ptr)  const { return ptr > in_ptr; }
  786|       |    bool operator>=(const TYPE * in_ptr) const { return ptr >= in_ptr; }
  787|       |
  788|       |    // Stubs for debug-related functions when outside debug mode.
  789|       |    int DebugGetCount() const { return -1; }
  790|       |    bool DebugIsArray() const { emp_assert(false); return false; }
  791|       |    size_t DebugGetArrayBytes() const { return 0; }
  792|       |    bool DebugIsActive() const { return true; }
  793|       |    bool OK() const { return true; }
  794|       |  };
  795|       |
  796|       |#endif
  797|       |
  798|       |  // IO
  799|      0|  /*_FORCE_COVER_START_*/template <typename T>
  800|      0|  std::ostream & operator<<(std::ostream & out, const emp::Ptr<T> & ptr) {
  801|      0|    out << ptr.Raw();
  802|      0|    return out;
  803|       |  }/*_FORCE_COVER_END_*/
  804|       |
  805|       |  // @CAO: Reading a pointer from a stream seems like a terrible idea in most situations, but I
  806|       |  // can imagine limited circumstances where it would be needed.
  807|      0|  /*_FORCE_COVER_START_*/template <typename T, typename... Ts>
  808|      0|  std::istream & operator>>(std::istream & is, emp::Ptr<T> & ptr) {
  809|      0|    T * val;
  810|      0|    is >> val;
  811|      0|    ptr = val;
  812|      0|    return is;
  813|       |  }/*_FORCE_COVER_END_*/
  814|       |
  815|       |  /// Convert a T* to a Ptr<T>.  By default, don't track.
  816|      2|  /*_FORCE_COVER_START_*/template <typename T> Ptr<T> ToPtr(T * _in, bool own=false) { return Ptr<T>(_in, own); }/*_FORCE_COVER_END_*/
  817|       |
  818|       |  /// Convert a T* to a Ptr<T> that we DO track.
  819|      0|  /*_FORCE_COVER_START_*/template <typename T> Ptr<T> TrackPtr(T * _in, bool own=true) { return Ptr<T>(_in, own); }/*_FORCE_COVER_END_*/
  820|       |
  821|       |  /// Create a new Ptr of the target type; use the args in the constructor.
  822|      0|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewPtr(ARGS &&... args) {
  823|      0|    auto ptr = new T(std::forward<ARGS>(args)...);
  824|       |    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.
  825|       |    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!
  826|       |    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.
  827|      0|    return Ptr<T>(ptr, true);
  828|       |  }/*_FORCE_COVER_END_*/
  829|       |
  830|       |  /// Copy an object pointed to and return a Ptr to the copy.
  831|      0|  /*_FORCE_COVER_START_*/template <typename T> Ptr<T> CopyPtr(Ptr<T> in) { return NewPtr<T>(*in); }/*_FORCE_COVER_END_*/
  832|       |
  833|       |  /// Copy a vector of objects pointed to; return a vector of Ptrs to the new copies.
  834|      0|  /*_FORCE_COVER_START_*/template <typename T> emp::vector<Ptr<T>> CopyPtrs(const emp::vector<Ptr<T>> & in) {
  835|      0|    emp::vector<Ptr<T>> out_ptrs(in.size());
  836|      0|    for (size_t i = 0; i < in.size(); i++) out_ptrs[i] = CopyPtr(in[i]);
  837|      0|    return out_ptrs;
  838|       |  }/*_FORCE_COVER_END_*/
  839|       |
  840|       |  /// Copy a vector of objects pointed to by using their Clone() member function; return vector.
  841|      0|  /*_FORCE_COVER_START_*/template <typename T> emp::vector<Ptr<T>> ClonePtrs(const emp::vector<Ptr<T>> & in) {
  842|      0|    emp::vector<Ptr<T>> out_ptrs(in.size());
  843|      0|    for (size_t i = 0; i < in.size(); i++) out_ptrs[i] = in[i]->Clone();
  844|      0|    return out_ptrs;
  845|       |  }/*_FORCE_COVER_END_*/
  846|       |
  847|       |  /// Create a pointer to an array of objects.
  848|      0|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewArrayPtr(size_t array_size, ARGS &&... args) {
  849|      0|    auto ptr = new T[array_size];                     // Build a new raw pointer.
  850|       |    // const size_t alloc_size = array_size * sizeof(T);
  851|       |    // auto ptr = (T*) malloc (alloc_size);
  852|      0|    emp_assert(ptr, array_size);                      // No exceptions in emscripten; assert alloc!
  853|       |    // for (size_t i = 0; i < array_size; i++) {         // Loop through all array elements.
  854|       |    //   new (ptr + i*sizeof(T)) T(args...);             //    ...and initialize them.
  855|       |    // }
  856|      0|    return Ptr<T>(ptr, array_size, true);
  857|       |  }/*_FORCE_COVER_END_*/
  858|       |
  859|       |
  860|       |}
  861|       |
  862|       |#endif // EMP_PTR_H
  863|       |

/home/emily/repos/Empirical_MoreTests/coverage_source/base/array.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file array.h
    7|       | *  @brief A drop-in wrapper for std::array; adds on bounds checking in debug mode.
    8|       | *  @note Status: RELEASE
    9|       | *
   10|       | *  If EMP_NDEBUG is set, emp::array is just an alias for std::array.
   11|       | *  Otherwise, every time an array is accessed, tests are done to make sure that the
   12|       | *  access is legal.
   13|       | *
   14|       | *  @todo Add tests in array::front and array::back to ensure not empty.
   15|       | *  @todo Add tests for get.
   16|       | */
   17|       |
   18|       |
   19|       |#ifndef EMP_ARRAY_H
   20|       |#define EMP_ARRAY_H
   21|       |
   22|       |#include <initializer_list>
   23|       |#include <array>
   24|       |
   25|       |#include "assert.h"
   26|       |#include "../meta/TypeID.h"
   27|       |
   28|       |#ifdef EMP_NDEBUG
   29|       |
   30|       |namespace emp {
   31|       |  /// In release mode, emp::array is simply an alias for std::array.
   32|       |  template <typename T, size_t N> using array = std::array<T,N>;
   33|       |}
   34|       |
   35|       |#else
   36|       |
   37|       |namespace emp {
   38|       |
   39|       |  /// We are in debug mode, so emp::array has the same interface as std::array, but with extra
   40|       |  /// bounds checking.  Using vector as our base since it has the right pieces and is dyanmic.
   41|       |  template <typename T, size_t N>
   42|       |  class array : public std::vector<T> {
   43|       |  private:
   44|       |    using this_t = emp::array<T,N>;
   45|       |    using base_t = std::vector<T>;
   46|       |
   47|       |  public:
   48|       |    bool valid;
   49|       |
   50|       |    /// Setup an iterator wrapper to make sure that they're valid.
   51|       |    template<typename ITERATOR_T>
   52|       |    struct iterator_wrapper : public ITERATOR_T {
   53|       |      using this_t = iterator_wrapper<ITERATOR_T>;
   54|       |      using wrapped_t = ITERATOR_T;
   55|       |      using vec_t = emp::array<T,N>;
   56|       |
   57|       |      /// What vector was this iterator created from?
   58|       |      const vec_t * v_ptr;
   59|       |
   60|      0|      /*_FORCE_COVER_START_*/iterator_wrapper(const ITERATOR_T & _in, const vec_t * _v) : ITERATOR_T(_in), v_ptr(_v) { ; }/*_FORCE_COVER_END_*/
   61|      0|      /*_FORCE_COVER_START_*/iterator_wrapper(const this_t &) = default/*_FORCE_COVER_END_*/;
   62|      0|      /*_FORCE_COVER_START_*/iterator_wrapper(this_t &&) = default/*_FORCE_COVER_END_*/;
   63|      0|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
   64|       |
   65|       |      // Debug tools to make sure this iterator is okay.
   66|      0|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
   67|      0|        if (v_ptr == nullptr) return false;                // Invalid vector
   68|      0|        if (!v_ptr->valid) return false;                   // Vector has been deleted!
   69|      0|        size_t pos = (size_t) (*this - v_ptr->begin());
   70|      0|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
   71|      0|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
   72|      0|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
   73|      0|        return true;
   74|       |      }/*_FORCE_COVER_END_*/
   75|       |
   76|      0|      /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
   77|      0|      /*_FORCE_COVER_START_*/this_t & operator=(this_t &&) = default/*_FORCE_COVER_END_*/;
   78|       |
   79|      0|      /*_FORCE_COVER_START_*/operator ITERATOR_T() { return *this; }/*_FORCE_COVER_END_*/
   80|      0|      /*_FORCE_COVER_START_*/operator const ITERATOR_T() const { return *this; }/*_FORCE_COVER_END_*/
   81|       |
   82|      0|      /*_FORCE_COVER_START_*/auto & operator*() {
   83|      0|        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.
   84|      0|        return wrapped_t::operator*();
   85|       |      }/*_FORCE_COVER_END_*/
   86|      0|      /*_FORCE_COVER_START_*/const auto & operator*() const {
   87|      0|        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.
   88|      0|        return wrapped_t::operator*();
   89|       |      }/*_FORCE_COVER_END_*/
   90|       |
   91|      0|      /*_FORCE_COVER_START_*/auto operator->() {
   92|      0|        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.
   93|      0|        return wrapped_t::operator->();
   94|       |      }/*_FORCE_COVER_END_*/
   95|      0|      /*_FORCE_COVER_START_*/const auto operator->() const {
   96|      0|        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.
   97|      0|        return wrapped_t::operator->();
   98|       |      }/*_FORCE_COVER_END_*/
   99|       |
  100|      0|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  101|      0|      /*_FORCE_COVER_START_*/this_t operator++(int x) { emp_assert(OK(true,false)); return this_t(wrapped_t::operator++(x), v_ptr); }/*_FORCE_COVER_END_*/
  102|      0|      /*_FORCE_COVER_START_*/this_t & operator--() { emp_assert(OK(false,true)); wrapped_t::operator--(); return *this; }/*_FORCE_COVER_END_*/
  103|      0|      /*_FORCE_COVER_START_*/this_t operator--(int x) { emp_assert(OK(false,true)); return this_t(wrapped_t::operator--(x), v_ptr); }/*_FORCE_COVER_END_*/
  104|       |
  105|      0|      /*_FORCE_COVER_START_*/auto operator+(int in) { emp_assert(OK()); return this_t(wrapped_t::operator+(in), v_ptr); }/*_FORCE_COVER_END_*/
  106|      0|      /*_FORCE_COVER_START_*/auto operator-(int in) { emp_assert(OK()); return this_t(wrapped_t::operator-(in), v_ptr); }/*_FORCE_COVER_END_*/
  107|      0|      /*_FORCE_COVER_START_*/auto operator-(const this_t & in) { emp_assert(OK()); return ((wrapped_t) *this) - (wrapped_t) in; }/*_FORCE_COVER_END_*/
  108|       |
  109|      0|      /*_FORCE_COVER_START_*/this_t & operator+=(int in) { emp_assert(OK()); wrapped_t::operator+=(in); return *this; }/*_FORCE_COVER_END_*/
  110|      0|      /*_FORCE_COVER_START_*/this_t & operator-=(int in) { emp_assert(OK()); wrapped_t::operator-=(in); return *this; }/*_FORCE_COVER_END_*/
  111|      0|      /*_FORCE_COVER_START_*/auto & operator[](int offset) { emp_assert(OK()); return wrapped_t::operator[](offset); }/*_FORCE_COVER_END_*/
  112|       |    };
  113|       |
  114|       |    using iterator = iterator_wrapper< typename base_t::iterator >;
  115|       |    using const_iterator = iterator_wrapper< typename base_t::const_iterator >;
  116|       |    using reverse_iterator = iterator_wrapper< typename base_t::reverse_iterator >;
  117|       |    using const_reverse_iterator = iterator_wrapper< typename base_t::const_reverse_iterator >;
  118|       |    using value_type = T;
  119|       |    using size_type = typename base_t::size_type;
  120|       |    using reference = typename base_t::reference;
  121|       |    using const_reference = typename base_t::const_reference;
  122|       |
  123|      1|    /*_FORCE_COVER_START_*/array() : base_t(N), valid(true) {}/*_FORCE_COVER_END_*/;
  124|      0|    /*_FORCE_COVER_START_*/array(const this_t & _in) : base_t(_in), valid(true) { emp_assert(_in.size() == N); }/*_FORCE_COVER_END_*/;
  125|      0|    /*_FORCE_COVER_START_*/array(std::initializer_list<T> in_list) : base_t(in_list), valid(true) { emp_assert(size() == N); }/*_FORCE_COVER_END_*/
  126|      0|    /*_FORCE_COVER_START_*/array(const base_t & in) : base_t(in), valid(true) { emp_assert(size() == N); }/*_FORCE_COVER_END_*/   // Emergency fallback
  127|      0|    /*_FORCE_COVER_START_*/template <typename InputIt>
  128|      0|    /*_FORCE_COVER_START_*/array(InputIt first, InputIt last) : base_t(first, last), valid(true) { emp_assert(size() == N); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  129|      1|    /*_FORCE_COVER_START_*/~array() { valid=false; }/*_FORCE_COVER_END_*/ // No longer valid when array is deleted.
  130|       |
  131|      0|    /*_FORCE_COVER_START_*/operator std::array<T,N>() {
  132|      0|      std::array<T,N> ar;
  133|      0|      for (size_t i = 0; i < N; i++) ar[i] = base_t::operator[](i);
  134|      0|      return ar;
  135|       |    }/*_FORCE_COVER_END_*/
  136|       |
  137|      0|    /*_FORCE_COVER_START_*/constexpr size_t size() const { return N; }/*_FORCE_COVER_END_*/
  138|       |
  139|      0|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(base_t::begin(), this); }/*_FORCE_COVER_END_*/
  140|      0|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(base_t::begin(), this); }/*_FORCE_COVER_END_*/
  141|      0|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(base_t::end(), this); }/*_FORCE_COVER_END_*/
  142|      0|    /*_FORCE_COVER_START_*/const_iterator end() const noexcept { return const_iterator(base_t::end(), this); }/*_FORCE_COVER_END_*/
  143|       |
  144|      0|    /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
  145|       |
  146|    100|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  147|    100|      emp_assert(pos < N, pos, N);
  148|    100|      return base_t::operator[](pos);
  149|    100|    }/*_FORCE_COVER_END_*/
  150|       |
  151|      0|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  152|      0|      emp_assert(pos < N, pos, N);
  153|      0|      return base_t::operator[](pos);
  154|       |    }/*_FORCE_COVER_END_*/
  155|       |
  156|      0|    /*_FORCE_COVER_START_*/T & back() { emp_assert(N > 0); return base_t::back(); }/*_FORCE_COVER_END_*/
  157|      0|    /*_FORCE_COVER_START_*/const T & back() const { emp_assert(N > 0); return base_t::back(); }/*_FORCE_COVER_END_*/
  158|      0|    /*_FORCE_COVER_START_*/T & front() { emp_assert(N > 0); return base_t::front(); }/*_FORCE_COVER_END_*/
  159|      0|    /*_FORCE_COVER_START_*/const T & front() const { emp_assert(N > 0); return base_t::front(); }/*_FORCE_COVER_END_*/
  160|       |
  161|      0|    /*_FORCE_COVER_START_*/void fill(const T & val) { this->assign(N, val); }/*_FORCE_COVER_END_*/
  162|       |
  163|       |    // Functions to make sure to throw an error on:
  164|       |
  165|      0|    /*_FORCE_COVER_START_*/void resize(size_t new_size) { emp_assert(false, "invalid operation for array!"); }/*_FORCE_COVER_END_*/
  166|      0|    /*_FORCE_COVER_START_*/void resize(size_t new_size, const T & val) { emp_assert(false, "invalid operation for array!"); }/*_FORCE_COVER_END_*/
  167|       |
  168|      0|    /*_FORCE_COVER_START_*/template <typename... PB_Ts>
  169|      0|    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) { emp_assert(false, "invalid operation for array!"); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  170|      0|    /*_FORCE_COVER_START_*/void pop_back() { emp_assert(false, "invalid operation for array!"); }/*_FORCE_COVER_END_*/
  171|       |
  172|      0|    /*_FORCE_COVER_START_*/template <typename... ARGS>
  173|      0|    /*_FORCE_COVER_START_*/iterator insert(ARGS &&... args) {
  174|      0|      emp_assert(false, "invalid operation for array!");
  175|      0|      return iterator( base_t::insert(std::forward<ARGS>(args)...), this );
  176|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  177|       |
  178|      0|    /*_FORCE_COVER_START_*/template <typename... ARGS>
  179|      0|    /*_FORCE_COVER_START_*/iterator erase(ARGS &&... args) {
  180|      0|      emp_assert(false, "invalid operation for array!");
  181|      0|      return iterator( base_t::erase(std::forward<ARGS>(args)...), this );
  182|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  183|       |
  184|      0|    /*_FORCE_COVER_START_*/template <typename... ARGS>
  185|      0|    /*_FORCE_COVER_START_*/iterator emplace(ARGS &&... args) {
  186|      0|      emp_assert(false, "invalid operation for array!");
  187|      0|      return iterator( base_t::emplace(std::forward<ARGS>(args)...), this );
  188|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  189|       |
  190|      0|    /*_FORCE_COVER_START_*/template <typename... ARGS>
  191|      0|    /*_FORCE_COVER_START_*/void emplace_back(ARGS &&... args) {
  192|      0|      emp_assert(false, "invalid operation for array!");
  193|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  194|       |  };
  195|       |
  196|       |
  197|       |}
  198|       |
  199|       |// A crude, generic printing function for arrays.
  200|      0|/*_FORCE_COVER_START_*/template <typename T, size_t N>
  201|      0|std::ostream & operator<<(std::ostream & out, const emp::array<T,N> & v) {
  202|      0|  for (const T & x : v) out << x << " ";
  203|      0|  return out;
  204|       |}/*_FORCE_COVER_END_*/
  205|       |
  206|      0|/*_FORCE_COVER_START_*/template <typename T, size_t N>
  207|      0|std::istream & operator>>(std::istream & is, emp::array<T,N> & v) {
  208|      0|  for (T & x : v) is >> x;
  209|      0|  return is;
  210|       |}/*_FORCE_COVER_END_*/
  211|       |
  212|       |#endif
  213|       |
  214|       |namespace emp{
  215|       |  /// Ensure that emp::array works with TypeID
  216|       |  template <typename T, size_t N> struct TypeID<emp::array<T,N>> {
  217|       |    static std::string GetName() {
  218|       |      std::stringstream ss;
  219|       |      ss << "emp::array<" << TypeID<T>::GetName() << "," << N << ">";
  220|       |      return ss.str();
  221|       |    }
  222|       |  };
  223|       |}
  224|       |
  225|       |#endif
  226|       |

/home/emily/repos/Empirical_MoreTests/coverage_source/base/assert.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file assert.h
    7|       | *  @brief A more dynamic replacement for standard library asserts.
    8|       | *  @note Status: RELEASE
    9|       | *
   10|       | *  A replacement for the system-level assert.h, called "emp_assert"
   11|       | *  Added functionality:
   12|       | *   - If compiled with Emscripten, will provide pop-up alerts in a web browser.
   13|       | *   - emp_assert can take additional arguments.  If the assert is triggered, those extra
   14|       | *     arguments will be evaluated and printed.
   15|       | *   - if NDEBUG -or- EMP_NDEBUG is defined, the expression in emp_assert() is not evaluated.
   16|       | *   - if EMP_TDEBUG is defined, emp_assert() goes into test mode and records failures, but
   17|       | *     does not abort.  (useful for unit tests of asserts)
   18|       | *
   19|       | *  Example:
   20|       | *
   21|       | *     int a = 6;
   22|       | *     emp_assert(a==5, a);
   23|       | *
   24|       | *  When compiled in debug mode (i.e. without the -DNDEBUG flag), this will trigger an assertion
   25|       | *  error and print the value of a.
   26|       | *
   27|       | *
   28|       | *  @todo: Add emp_assert_warning() for non-terminating assert.  Should be able to disable with
   29|       | *         a command-line option (-DEMP_NO_WARNINGS)
   30|       | */
   31|       |
   32|       |#ifndef EMP_ASSERT_H
   33|       |#define EMP_ASSERT_H
   34|       |
   35|       |#include <iostream>
   36|       |#include <string>
   37|       |#include <sstream>
   38|       |
   39|       |#include "macros.h"
   40|       |
   41|       |/// @cond DEFINES
   42|       |
   43|       |/// If we are in emscripten, make sure to include the header.
   44|       |#ifdef EMSCRIPTEN
   45|       |#include <emscripten.h>
   46|       |#endif
   47|       |
   48|       |/// NDEBUG and TDEBUG should trigger their EMP equivilents.
   49|       |#ifdef NDEBUG
   50|       |#define EMP_NDEBUG
   51|       |#endif
   52|       |
   53|       |#ifdef TDEBUG
   54|       |#define EMP_TDEBUG
   55|       |#endif
   56|       |
   57|       |
   58|       |/// Helper macros used throughout...
   59|      0|#define emp_assert_TO_PAIR(X) EMP_STRINGIFY(X) , X
   60|       |
   61|       |/// Turn off all asserts in EMP_NDEBUG
   62|       |#ifdef EMP_NDEBUG
   63|       |namespace emp {
   64|       |  constexpr bool assert_on = false;
   65|       |}
   66|       |
   67|       |// GROUP 1:   --- Debug OFF ---
   68|       |
   69|       |/// Ideally, this assert should use the expression (to prevent compiler error), but should not
   70|       |/// generate any assembly code.  For now, just make it blank (other options commented out)
   71|       |#define emp_assert(...)
   72|       |// #define emp_assert(EXPR) ((void) sizeof(EXPR) )
   73|       |// #define emp_assert(EXPR, ...) { constexpr bool __emp_assert_tmp = false && (EXPR); (void) __emp_assert_tmp; }
   74|       |
   75|       |// Asserts to check only when in Emscripten should also be disabled.
   76|       |#define emp_emscripten_assert(...)
   77|       |
   78|       |
   79|       |// GROUP 2:   --- Unit Testing ON ---
   80|       |#elif defined(EMP_TDEBUG)           // EMP_NDEBUG not set, but EMP_TDEBUG is!
   81|       |
   82|       |namespace emp {
   83|       |  constexpr bool assert_on = true;
   84|       |  struct AssertFailInfo {
   85|       |    std::string filename;
   86|       |    int line_num;
   87|       |    std::string error;
   88|       |  };
   89|       |  AssertFailInfo assert_fail_info;
   90|       |  bool assert_last_fail = false;
   91|       |
   92|       |  template <typename... EXTRA>
   93|       |  bool assert_trigger(std::string filename, size_t line, std::string expr) {
   94|       |    emp::assert_fail_info.filename = __FILE__;
   95|       |    emp::assert_fail_info.line_num = __LINE__;
   96|       |    emp::assert_fail_info.error = expr;
   97|       |    emp::assert_last_fail = true;
   98|       |
   99|       |    return true;
  100|       |  }
  101|       |
  102|       |  void assert_clear() { emp::assert_last_fail = false; }
  103|       |}
  104|       |
  105|       |// Unit Testing ON
  106|       |
  107|      0|#define emp_assert(...)                                                                       \
  108|      0|  do {                                                                                        \
  109|      0|    !(EMP_GET_ARG_1(__VA_ARGS__, ~)) &&                                                       \
  110|      0|    emp::assert_trigger(__FILE__, __LINE__, EMP_STRINGIFY( EMP_GET_ARG_1(__VA_ARGS__, ~) ));  \
  111|      0|  } while(0)
  112|       |
  113|       |// Unit-testing asserts to check only when in Emscripten should depend on if we are in Emscripten
  114|       |#ifdef EMSCRIPTEN
  115|      0|#define emp_emscripten_assert(...) emp_assert(__VA_ARGS__)
  116|       |#else
  117|       |#define emp_emscripten_assert(...)
  118|       |#endif
  119|       |
  120|       |
  121|       |// GROUP 3:   --- Emscripten debug ON ---
  122|       |#elif EMSCRIPTEN  // Neither EMP_NDEBUG nor EMP_TDEBUG set, but compiling with Emscripten
  123|       |
  124|       |namespace emp {
  125|       |  constexpr bool assert_on = true;
  126|       |  static int TripAssert() {
  127|       |    static int trip_count = 0;
  128|       |    return ++trip_count;
  129|       |  }
  130|       |
  131|       |  /// Base case for assert_print...
  132|       |  void assert_print(std::stringstream &) { ; }
  133|       |
  134|       |  /// Print out information about the next variable and recurse...
  135|       |  template <typename T, typename... EXTRA>
  136|       |  void assert_print(std::stringstream & ss, std::string name, T && val, EXTRA &&... extra) {
  137|       |    ss << name << ": [" << val << "]" << std::endl;
  138|       |    assert_print(ss, std::forward<EXTRA>(extra)...);
  139|       |  }
  140|       |
  141|       |  template <typename IGNORE, typename... EXTRA>
  142|       |  bool assert_trigger(std::string filename, size_t line, std::string expr, IGNORE, EXTRA &&... extra) {
  143|       |    std::stringstream ss;
  144|       |    ss << "Assert Error (In " << filename << " line " << line << "): " << expr << '\n';
  145|       |    assert_print(ss, std::forward<EXTRA>(extra)...);
  146|       |    if (emp::TripAssert() <= 3) {
  147|       |      EM_ASM_ARGS({ msg = Pointer_stringify($0); alert(msg); }, ss.str().c_str());
  148|       |    }
  149|       |
  150|       |    // Print the current state of the stack.
  151|       |    EM_ASM( console.log('Callstack:\n' + stackTrace()); );
  152|       |    return true;
  153|       |  }
  154|       |}
  155|       |
  156|       |// Debug; Emscripten ON
  157|       |
  158|      0|#define emp_assert(...)                                                                       \
  159|      0|  do {                                                                                        \
  160|      0|    !(EMP_GET_ARG_1(__VA_ARGS__, ~)) &&                                                       \
  161|      0|    emp::assert_trigger(__FILE__, __LINE__, EMP_WRAP_ARGS(emp_assert_TO_PAIR, __VA_ARGS__) ); \
  162|      0|  } while(0)
  163|       |
  164|       |// Emscripten asserts should be on since we are in Emscripten
  165|      0|#define emp_emscripten_assert(...) emp_assert(__VA_ARGS__)
  166|       |
  167|       |
  168|       |// GROUP 3:   --- Debug ON, but Emscripten OFF ---
  169|       |#else
  170|       |
  171|       |namespace emp {
  172|       |  constexpr bool assert_on = true;
  173|       |
  174|       |  /// Base case for assert_print...
  175|      0|  void assert_print() { ; }
  176|       |
  177|       |  /// Print out information about the next variable and recurse...
  178|      0|  /*_FORCE_COVER_START_*/template <typename T, typename... EXTRA>
  179|      0|  void assert_print(std::string name, T && val, EXTRA &&... extra) {
  180|      0|    std::cerr << name << ": [" << val << "]" << std::endl;
  181|      0|    assert_print(std::forward<EXTRA>(extra)...);
  182|      0|  }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA2_KcmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printImJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIPKvJRA16_KciS5_bEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIiJRA16_KcbEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIbJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA15_KcmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRA36_KcJRA3_S1_RmRA14_S1_PKvRA16_S1_bEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA14_KcPKvRA16_S2_bEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIPKvJRA16_KcbEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRA38_KcJRA3_S1_RmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRA35_KcJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA47_KcRA45_S2_EEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRA45_KcJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRA19_KcJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRA30_KcJRA3_S1_RmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRKmJRA32_KcRA30_S3_EEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRA30_KcJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA32_KcRA30_S2_EEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  183|       |
  184|      0|  /*_FORCE_COVER_START_*/template <typename IGNORE, typename... EXTRA>
  185|      0|  bool assert_trigger(std::string filename, size_t line, std::string expr, IGNORE, EXTRA &&... extra) {
  186|      0|    std::cerr << "Assert Error (In " << filename << " line " << line
  187|      0|              <<  "): " << expr << std::endl;
  188|      0|    assert_print(std::forward<EXTRA>(extra)...);
  189|      0|    return true;
  190|      0|  }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA4_KcRmRA2_S1_mEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmS6_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA14_KcPKvRA16_S1_iS7_bEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSD_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA4_KcRmRA15_S1_mEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA38_KcRA36_S1_RA3_S1_RmRA14_S1_PKvRA16_S1_bEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSK_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA40_KcRA38_S1_RA3_S1_RmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSE_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIPKvJEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmS8_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA3_KcRmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSA_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA37_KcRA35_S1_EEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSB_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA3_KcRmRA47_S1_RA45_S1_EEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSE_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIPiJRA21_KcRA19_S2_EEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA32_KcRA30_S1_RA3_S1_RmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSE_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA5_KcRmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSA_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA7_KcRKmRA32_S1_RA30_S1_EEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSF_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIPcJRA21_KcRA19_S2_EEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA7_KcRmRA32_S1_RA30_S1_EEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSE_T_DpOT0_
  ------------------
  191|       |}
  192|       |
  193|       |/// @endcond
  194|       |
  195|       |// Debug; Not Emscripten
  196|       |
  197|       |/// Require a specified condition to be true.  If it is false, immediately halt execution.
  198|       |/// Note: If NDEBUG is defined, emp_assert() will not do anything.
  199|      0|#define emp_assert(...)                                                                          \
  200|  1.77k|  do {                                                                                           \
  201|  1.77k|    !(EMP_GET_ARG_1(__VA_ARGS__, ~)) &&                                                          \
  202|  1.77k|    emp::assert_trigger(__FILE__, __LINE__, EMP_WRAP_ARGS(emp_assert_TO_PAIR, __VA_ARGS__) ) &&  \
  203|  1.77k|    (abort(), false);                                                                            \
  204|  1.77k|  } while(0)
  205|       |
  206|       |// Emscripten-only asserts should be disabled since we are not in Emscripten
  207|       |/// Require a specified condition to be true if this program was compiled to Javascript with Emscripten.
  208|       |/// Note: If NDEBUG is defined, emp_emscripten_assert() will not do anything.
  209|      0|#define emp_emscripten_assert(...) emp_assert(__VA_ARGS__)
  210|       |
  211|       |/// @cond DEFINES
  212|       |
  213|       |#endif // NDEBUG
  214|       |
  215|       |
  216|       |#endif // Include guard
  217|       |
  218|       |/// @endcond
  219|       |

/home/emily/repos/Empirical_MoreTests/coverage_source/base/errors.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file  errors.h
    7|       | *  @brief Tools to help manage various problems in command-line or Emscripten-based applications.
    8|       | *  @note Status: ALPHA
    9|       | *
   10|       | *  There are three possible recipiants for all errors/warnings.
   11|       | *  - The end-user if the problem stems from inputs they provided to the executable.
   12|       | *  - The library user if the problem is due to mis-use of library functionality.
   13|       | *  - The library developers if something that should be impossible occurs.
   14|       | *
   15|       | *  There are also three types of problmes to notify about:
   16|       | *  - Warnings if something looks suspicious, but isn't technically a problem.
   17|       | *  - Errors if something has gone so horribly wrong that it is impossible to recover from.
   18|       | *  - Exceptions if something didn't go the way we expected, but we can still recover.
   19|       | *
   20|       | *  In general, most of the content of this file is targeted at providing useful tools for library
   21|       | *  users; end-users should receive more customized messages and asserts should capture
   22|       | *  suposedly "impossible" situations that none-the-less occur in the library itself.
   23|       | *
   24|       | *  NOTES:
   25|       | *  - Whenever possible, exceptions should be preferred.  They are more specific than warnings,
   26|       | *    but don't halt execution like errors.
   27|       | *  - Warnings should always detail what should be done differently to surpress the warning.
   28|       | *
   29|       | *
   30|       | *  @todo We should move over to a pure replacement for exceptions.
   31|       | *    - Different types of exceptions can trigger a signal.  Actions should return a bool
   32|       | *      indicating whether the exception was fixed.
   33|       | *    - Remaining exceptions are recorded and passed back up the chain to (hopefully) be caught.
   34|       | *    - Uncaught exceptions should have a default behavior when Resolved.  Exceptions could have
   35|       | *      various resolve times: Next exception added, Next exception check, when ResolveExceptions()
   36|       | *      is run, End of program, or ASAP. (perhaps)
   37|       |*/
   38|       |
   39|       |#ifndef EMP_ERRORS_H
   40|       |#define EMP_ERRORS_H
   41|       |
   42|       |#include <iostream>
   43|       |#include <map>
   44|       |#include <sstream>
   45|       |#include <string>
   46|       |
   47|       |/// If we are in emscripten, make sure to include the header.
   48|       |#ifdef EMSCRIPTEN
   49|       |#include <emscripten.h>
   50|       |#endif
   51|       |
   52|       |namespace emp {
   53|       |
   54|       |  /// Information about an exception that has occured.
   55|       |  struct ExceptInfo {
   56|       |    std::string id;         ///< A unique string ID for this exception type.
   57|       |    std::string desc;       ///< A detailed description of thie exception.
   58|       |    bool default_to_error;  ///< Should we default to an error (or a warning) if not resolved?
   59|       |  };
   60|       |
   61|       |  /// Function to generate an empty exception (returned when an exception is checked, but none exist.)
   62|      1|  static const ExceptInfo & GetEmptyExcept() {
   63|      1|    static ExceptInfo fail_info{"","",false};
   64|      1|    return fail_info;
   65|      1|  }
   66|       |
   67|       |  /// A map of all exceptions that have occurred and are awaiting to be dealt with.
   68|     10|  static std::multimap<std::string, ExceptInfo> & GetExceptMap() {
   69|     10|    static std::multimap<std::string, ExceptInfo> except_map;
   70|     10|    return except_map;
   71|     10|  }
   72|       |
   73|       |  /// Provide information about an exception that needs to be triggered.
   74|      3|  inline void TriggerExcept(const std::string & in_id, const std::string & in_desc, bool in_error=true) {
   75|      3|    GetExceptMap().emplace(in_id, ExceptInfo({in_id, in_desc, in_error}));
   76|      3|  }
   77|       |
   78|       |  /// Get the first waiting exception.
   79|      0|  inline const ExceptInfo & GetExcept(const std::string & id) {
   80|      0|    auto & fail_map = GetExceptMap();
   81|      0|    auto it = fail_map.find(id);
   82|      0|    if (it != fail_map.end()) return it->second;
   83|      0|    return GetEmptyExcept();
   84|      0|  }
   85|       |
   86|       |  /// Get and *remove* a waiting exception.
   87|      1|  inline ExceptInfo PopExcept(const std::string & id) {
   88|      1|    auto & fail_map = GetExceptMap();
   89|      1|    auto it = fail_map.find(id);
   90|      1|    auto out = GetEmptyExcept();
   91|      1|    if (it != fail_map.end()) { out = it->second; fail_map.erase(it); }
   92|      1|    return out;
   93|      1|  }
   94|       |
   95|       |  /// How many exceptions are waiting to be dealt with?
   96|      3|  inline size_t CountExcepts() { return GetExceptMap().size(); }
   97|       |
   98|       |  /// Are any exceptions waiting?
   99|      0|  inline bool HasExcept() { return CountExcepts(); }
  100|       |
  101|       |  /// Are any exceptions of a particular type waiting?
  102|      2|  inline bool HasExcept(const std::string & id) { return GetExceptMap().count(id); }
  103|       |
  104|       |  /// Remove all waiting exceptions.
  105|      1|  inline void ClearExcepts() { GetExceptMap().clear(); }
  106|       |
  107|       |  /// Remove all waiting exceptions of the desginated type.
  108|      0|  inline void ClearExcept(const std::string & id) {
  109|      0|    auto & fail_map = GetExceptMap();
  110|      0|    auto it = fail_map.find(id);
  111|      0|    if (it != fail_map.end()) fail_map.erase(it);
  112|      0|  }
  113|       |
  114|       |  namespace {
  115|       |    // Copy all of the args into the stringstream.
  116|       |    // Base case
  117|      0|    void Notify_impl(std::stringstream &) { ; }
  118|       |
  119|       |    // For each arg, copy it into the provided stringstream and recurse to do the rest.
  120|      0|    /*_FORCE_COVER_START_*/template <typename T, typename... Ts>
  121|      0|    void Notify_impl(std::stringstream & ss, T && arg1, Ts &&... args) {
  122|      0|      ss << std::forward<T>(arg1);
  123|      0|      Notify_impl(ss, std::forward<Ts>(args)...);
  124|       |    }/*_FORCE_COVER_END_*/
  125|       |  }
  126|       |
  127|       |  /// Send information to a program user (via standard error in native mode, or alter in Emscripten)
  128|      0|  /*_FORCE_COVER_START_*/template <typename... Ts>
  129|      0|  void Notify(Ts &&... args) {
  130|      0|    std::stringstream ss;
  131|      0|    Notify_impl(ss, std::forward<Ts>(args)...);
  132|      0|#ifdef EMSCRIPTEN
  133|      0|    EM_ASM_ARGS({ msg = Pointer_stringify($0); alert(msg); }, ss.str().c_str());
  134|      0|#else
  135|      0|    std::cerr << ss.str() << std::endl;
  136|      0|#endif
  137|       |  }/*_FORCE_COVER_END_*/
  138|       |
  139|       |  /// End user has done something possibly a problem.
  140|      0|  /*_FORCE_COVER_START_*/template <typename... Ts>
  141|      0|  void NotifyWarning(Ts &&... msg) { Notify("WARNING: ", std::forward<Ts>(msg)...); }/*_FORCE_COVER_END_*/
  142|       |
  143|       |  /// End user has done something resulting in an non-recoverable problem.
  144|      0|  /*_FORCE_COVER_START_*/template <typename... Ts>
  145|      0|  void NotifyError(Ts &&... msg) { Notify("ERROR: ", std::forward<Ts>(msg)...); }/*_FORCE_COVER_END_*/
  146|       |
  147|       |  /// Library user has made an error in how they are using the library.
  148|      0|  /*_FORCE_COVER_START_*/template <typename... Ts>
  149|      0|  void LibraryWarning(Ts &&... msg) { Notify("EMPIRICAL USE WARNING: ", std::forward<Ts>(msg)...); }/*_FORCE_COVER_END_*/
  150|       |
  151|       |  /// Library user has made an error in how they are using the library.
  152|      0|  /*_FORCE_COVER_START_*/template <typename... Ts>
  153|      0|  void LibraryError(Ts &&... msg) { Notify("EMPIRICAL USE ERROR: ", std::forward<Ts>(msg)...); }/*_FORCE_COVER_END_*/
  154|       |
  155|       |  /// Original library implementers must have made an error.
  156|      0|  /*_FORCE_COVER_START_*/template <typename... Ts>
  157|      0|  void InternalError(Ts &&... msg) { Notify("INTERNAL EMPIRICAL ERROR: ", std::forward<Ts>(msg)...); }/*_FORCE_COVER_END_*/
  158|       |
  159|       |}
  160|       |
  161|       |
  162|       |#endif
  163|       |

/home/emily/repos/Empirical_MoreTests/coverage_source/base/macros.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file macros.h
    7|       | *  @brief Generally useful macros that can perform cools tricks.
    8|       | *  @note Status: RELEASE
    9|       | *
   10|       | *
   11|       | *  Generally useful macros that can perform cools tricks.  As with all macros, use only
   12|       | *  after careful exclusion of alternative approaches.
   13|       | *
   14|       | *  The Macros to highlighted here are:
   15|       | *
   16|       | *  ===== String Handling and Printing =====
   17|       | *  EMP_PRINT_RESULT(A) will print to std::cout both the string that was passed into the
   18|       | *       macro and what that string evaluates to.
   19|       | *
   20|       | *  EMP_STRINGIFY(...) converts all arguments into a single string (including commas).
   21|       | *  EMP_STRINGIFY_EACH(...) converts each argument into a string (leaving commas).
   22|       | *
   23|       | *  ===== Managing variadic arguments =====
   24|       | *  EMP_COUNT_ARGS(...) returns the number of arguments in the __VA_ARGS__
   25|       | *  EMP_GET_ARG(N, ...) return the Nth arg that follows
   26|       | *  EMP_POP_ARGS(N, ...) remove the first N args, return the rest.
   27|       | *  EMP_PACK_ARGS(...) Group args together in parens so they are treated like one argument.
   28|       | *  EMP_DUPLICATE_ARGS(N, ...) makes N collated copies of all args to follow.
   29|       | *  EMP_CROP_ARGS_TO(N, ...) reduces N args (must have at least that many)
   30|       | *  EMP_FORCE_ARGS_TO(N, P, ...) Crops or pads (with p) args to be exactly N long.
   31|       | *  EMP_ROTATE_ARGS(...) Moves the first argument to the end of the arg list.
   32|       | *  EMP_SELECT_ARGS(PATTERN, ...) Uses the (repeating) patter to select arguments to keep.
   33|       | *    Pattern is an argument pack consisting of i (include) or x (exclude).
   34|       | *  EMP_GET_ODD_ARGS(...) will return all arguments at odd positions (1,3,5,7, etc.)
   35|       | *  EMP_GET_EVEN_ARGS(...) will return all arguments at odd positions (2,4,6,8, etc.)
   36|       | *  EMP_REVERSE_ARGS(...) Reverse the order of arguments passed in.
   37|       | *
   38|       | *  ===== Argument Manipulation and Formatting =====
   39|       | *  EMP_MERGE(...) merge all arguments (after conversion) into a single unit.
   40|       | *  EMP_WRAP_EACH(W, ...) will run macro W on each of the other args and concatinate them.
   41|       | *  EMP_LAYOUT(W, P, ...) Similar to EMP_WRAP_EACH, but puts a P between each arg pair.
   42|       | *  EMP_WRAP_ARGS(W, ...) Similar to EMP_WRAP_EACH, but puts a COMMA between each arg pair.
   43|       | *  EMP_WRAP_ARG_PAIRS(W, ...) Similar to EMP_WRAP_ARGS, but passes pairs of args into W.
   44|       | *
   45|       | *  ===== Macro Building =====
   46|       | *  EMP_ASSEMBLE_MACRO takes in a prefix and set of arguments and appends the size of the
   47|       | *  number of arguments to the prefix, and passes in all of the arguments.
   48|       | *
   49|       | *  EMP_ASSEMBLE_MACRO_1ARG assumes the first argument after the prefix should not count
   50|       | *  toward the size, but passed in anyway. (*_?ARG  works for more arguments up to 10).
   51|       | *
   52|       | *  EMP_FAKE_ARG or EMP_FAKE_2ARG behave as a single argument.  If, in manipulating them
   53|       | *  You make them become EMP_CONVERT_ARG_EMP_FAKE_ARG(A) or EMP_CONVERT_ARG_EMP_FAKE_2ARG(A)
   54|       | *  (i.e., prepend with EMP_CONVERT and provide an argument) it will trigger a conversion.
   55|       | *  If you prepend anything else similarly, it wil NOT trigger a conversion.
   56|       | *
   57|       | *  This is especially useful with _2ARG since anything unconverted will be a single
   58|       | *  argument, while anything converted will be two, allowing us to shift arguments
   59|       | *  to perform conditional behaviors.
   60|       | *
   61|       | *
   62|       | *  @todo We need to standardize how we handle macros that covert inputs to comma-separated
   63|       | *    results vs those that merge them together.  One option is to have comma-separated the
   64|       | *    default and then have an EMP_REMOVE_COMMAS (or somesuch)
   65|       | *
   66|       | *  @todo EMP_TYPES_TO_ARGS (not yet listed above) is poorly named.  Maybe EMP_DECLARE_ARGS?
   67|       | *
   68|       | *  @todo It would be useful to have EMP_WRAP_WITH_ID which passes in the position ID as the
   69|       | *    second argument.  This would allow us to, for example, streamline EMP_TYPES_TO_ARGS.
   70|       | *
   71|       | *  @todo A more generic EMP_WRAP macro that is specified on the fly.  For example:
   72|       | *      EMP_WRAP(W,2,4,A,B,a,b,c,d,e,f,g,h,i,j,k,l)
   73|       | *    would assume six args in each wrap, A, B, and the rest broken into groups of four. I.e.:
   74|       | *      W(A,B,a,b,c,d), W(A,B,e,f,g,h), W(A,B,i,j,k,l)
   75|       | */
   76|       |
   77|       |#ifndef EMP_MACROS_H
   78|       |#define EMP_MACROS_H
   79|       |
   80|       |#include "macro_math.h"
   81|       |
   82|       |/// The below values allow you to have EMP_FAKE_ARG or EMP_FAKE_2ARG as a single argument.
   83|       |/// If you prepend it with EMP_CONVERT it will trigger a conversion.  If you prepend anything
   84|       |/// else similarly, it wil NOT triggera a conversion (and stay a single argument)
   85|      0|#define EMP_CONVERT_ARG_EMP_FAKE_ARG(A) A
   86|      0|#define EMP_CONVERT_ARG_EMP_FAKE_2ARG(A) ~, A
   87|       |
   88|       |
   89|       |/// EMP_STRINGIFY takes any input, processes macros, and puts the result in quotes.converts all
   90|       |/// arguments into a single string (including commas).
   91|    185|#define EMP_STRINGIFY(...) EMP_STRINGIFY_IMPL(__VA_ARGS__)
   92|       |/// @cond MACROS
   93|    185|#define EMP_STRINGIFY_IMPL(...) #__VA_ARGS__
   94|       |/// @endcond
   95|       |
   96|       |/// @cond MACROS
   97|      0|#define EMP_PRINT_RESULT_IMPL(STREAM, LHS, RHS) STREAM << "[[" << LHS << "]] = [[" << RHS << "]]" << std::endl
   98|      0|#define EMP_PRINT_RESULT_TO(STREAM, A) EMP_PRINT_RESULT_IMPL(STREAM, #A, A)
   99|       |/// @endcond
  100|       |/// Print to std::cout both the string that was passed into the macro and what that string
  101|       |/// evaluates to.
  102|      0|#define EMP_PRINT_RESULT(A) EMP_PRINT_RESULT_IMPL(std::cout, #A, A)
  103|       |
  104|       |/// @cond MACROS
  105|      2|#define EMP_POP_ARGS_IMPL_1(A,...) __VA_ARGS__
  106|      0|#define EMP_POP_ARGS_IMPL_2(A,B,...) __VA_ARGS__
  107|      0|#define EMP_POP_ARGS_IMPL_4(A,B,C,D,...) __VA_ARGS__
  108|      0|#define EMP_POP_ARGS_IMPL_8(A,B,C,D,E,F,G,H,...) __VA_ARGS__
  109|      0|#define EMP_POP_ARGS_IMPL_16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,...) __VA_ARGS__
  110|      0|#define EMP_POP_ARGS_IMPL_32(...)  EMP_POP_ARGS_16(EMP_POP_ARGS_16(__VA_ARGS__) )
  111|      0|#define EMP_POP_ARGS_IMPL_64(...)  EMP_POP_ARGS_32(EMP_POP_ARGS_32(__VA_ARGS__) )
  112|      0|#define EMP_POP_ARGS_IMPL_128(...) EMP_POP_ARGS_64(EMP_POP_ARGS_64(__VA_ARGS__) )
  113|      0|#define EMP_POP_ARGS_IMPL_256(...) EMP_POP_ARGS_128(EMP_POP_ARGS_128(__VA_ARGS__) )
  114|      0|#define EMP_POP_ARGS_IMPL_512(...) EMP_POP_ARGS_256(EMP_POP_ARGS_256(__VA_ARGS__) )
  115|       |
  116|      0|#define EMP_POP_ARGS_0(...) __VA_ARGS__
  117|      2|#define EMP_POP_ARGS_1(...) EMP_POP_ARGS_IMPL_1(__VA_ARGS__)
  118|      0|#define EMP_POP_ARGS_2(...) EMP_POP_ARGS_IMPL_2(__VA_ARGS__)
  119|      0|#define EMP_POP_ARGS_4(...) EMP_POP_ARGS_IMPL_4(__VA_ARGS__)
  120|      0|#define EMP_POP_ARGS_8(...) EMP_POP_ARGS_IMPL_8(__VA_ARGS__)
  121|      0|#define EMP_POP_ARGS_16(...) EMP_POP_ARGS_IMPL_16(__VA_ARGS__)
  122|      0|#define EMP_POP_ARGS_32(...) EMP_POP_ARGS_IMPL_32(__VA_ARGS__)
  123|      0|#define EMP_POP_ARGS_64(...) EMP_POP_ARGS_IMPL_64(__VA_ARGS__)
  124|      0|#define EMP_POP_ARGS_128(...) EMP_POP_ARGS_IMPL_128(__VA_ARGS__)
  125|      0|#define EMP_POP_ARGS_256(...) EMP_POP_ARGS_IMPL_256(__VA_ARGS__)
  126|      0|#define EMP_POP_ARGS_512(...) EMP_POP_ARGS_IMPL_512(__VA_ARGS__)
  127|       |/// @endcond
  128|       |
  129|      0|#define EMP_POP_ARG(...) EMP_POP_ARGS_IMPL_1(__VA_ARGS__)
  130|       |/// remove the first N args, return the rest.
  131|      0|#define EMP_POP_ARGS(N, ...) EMP_EVAL( EMP_POP_ARGS_SUM EMP_EMPTY() (EMP_EVAL(EMP_DEC_TO_SUM(N)),__VA_ARGS__) )
  132|      0|#define EMP_POP_ARGS_SUM(S0,S1,S2,S3,S4,S5,S6,S7,S8,S9,...) EMP_POP_ARGS_##S0( EMP_POP_ARGS_##S1( EMP_POP_ARGS_##S2( EMP_POP_ARGS_##S3( EMP_POP_ARGS_##S4( EMP_POP_ARGS_##S5( EMP_POP_ARGS_##S6( EMP_POP_ARGS_##S7( EMP_POP_ARGS_##S8( EMP_POP_ARGS_##S9( __VA_ARGS__ ))))))))))
  133|       |
  134|       |/// Return the Nth arg that follows
  135|      0|#define EMP_GET_ARG(N, ...) EMP_GET_ARG_1( EMP_POP_ARGS( EMP_DEC(N), __VA_ARGS__ ) )
  136|       |/// @cond MACROS
  137|  1.77k|#define EMP_GET_ARG_1(...) EMP_GET_ARG_1_IMPL(__VA_ARGS__)
  138|  1.78k|#define EMP_GET_ARG_1_IMPL(A, ...) A
  139|      0|#define EMP_GET_ARG_2(...) EMP_GET_ARG_2_IMPL(__VA_ARGS__)
  140|      0|#define EMP_GET_ARG_2_IMPL(A, B, ...) B
  141|       |/// @endcond
  142|       |
  143|       |/// returns the number of arguments in the __VA_ARGS__
  144|      0|#define EMP_COUNT_ARGS(...) EMP_GET_ARG(1023, __VA_ARGS__, 1022, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001, 1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987, 986, 985, 984, 983, 982, 981, 980, 979, 978, 977, 976, 975, 974, 973, 972, 971, 970, 969, 968, 967, 966, 965, 964, 963, 962, 961, 960, 959, 958, 957, 956, 955, 954, 953, 952, 951, 950, 949, 948, 947, 946, 945, 944, 943, 942, 941, 940, 939, 938, 937, 936, 935, 934, 933, 932, 931, 930, 929, 928, 927, 926, 925, 924, 923, 922, 921, 920, 919, 918, 917, 916, 915, 914, 913, 912, 911, 910, 909, 908, 907, 906, 905, 904, 903, 902, 901, 900, 899, 898, 897, 896, 895, 894, 893, 892, 891, 890, 889, 888, 887, 886, 885, 884, 883, 882, 881, 880, 879, 878, 877, 876, 875, 874, 873, 872, 871, 870, 869, 868, 867, 866, 865, 864, 863, 862, 861, 860, 859, 858, 857, 856, 855, 854, 853, 852, 851, 850, 849, 848, 847, 846, 845, 844, 843, 842, 841, 840, 839, 838, 837, 836, 835, 834, 833, 832, 831, 830, 829, 828, 827, 826, 825, 824, 823, 822, 821, 820, 819, 818, 817, 816, 815, 814, 813, 812, 811, 810, 809, 808, 807, 806, 805, 804, 803, 802, 801, 800, 799, 798, 797, 796, 795, 794, 793, 792, 791, 790, 789, 788, 787, 786, 785, 784, 783, 782, 781, 780, 779, 778, 777, 776, 775, 774, 773, 772, 771, 770, 769, 768, 767, 766, 765, 764, 763, 762, 761, 760, 759, 758, 757, 756, 755, 754, 753, 752, 751, 750, 749, 748, 747, 746, 745, 744, 743, 742, 741, 740, 739, 738, 737, 736, 735, 734, 733, 732, 731, 730, 729, 728, 727, 726, 725, 724, 723, 722, 721, 720, 719, 718, 717, 716, 715, 714, 713, 712, 711, 710, 709, 708, 707, 706, 705, 704, 703, 702, 701, 700, 699, 698, 697, 696, 695, 694, 693, 692, 691, 690, 689, 688, 687, 686, 685, 684, 683, 682, 681, 680, 679, 678, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668, 667, 666, 665, 664, 663, 662, 661, 660, 659, 658, 657, 656, 655, 654, 653, 652, 651, 650, 649, 648, 647, 646, 645, 644, 643, 642, 641, 640, 639, 638, 637, 636, 635, 634, 633, 632, 631, 630, 629, 628, 627, 626, 625, 624, 623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 613, 612, 611, 610, 609, 608, 607, 606, 605, 604, 603, 602, 601, 600, 599, 598, 597, 596, 595, 594, 593, 592, 591, 590, 589, 588, 587, 586, 585, 584, 583, 582, 581, 580, 579, 578, 577, 576, 575, 574, 573, 572, 571, 570, 569, 568, 567, 566, 565, 564, 563, 562, 561, 560, 559, 558, 557, 556, 555, 554, 553, 552, 551, 550, 549, 548, 547, 546, 545, 544, 543, 542, 541, 540, 539, 538, 537, 536, 535, 534, 533, 532, 531, 530, 529, 528, 527, 526, 525, 524, 523, 522, 521, 520, 519, 518, 517, 516, 515, 514, 513, 512, 511, 510, 509, 508, 507, 506, 505, 504, 503, 502, 501, 500, 499, 498, 497, 496, 495, 494, 493, 492, 491, 490, 489, 488, 487, 486, 485, 484, 483, 482, 481, 480, 479, 478, 477, 476, 475, 474, 473, 472, 471, 470, 469, 468, 467, 466, 465, 464, 463, 462, 461, 460, 459, 458, 457, 456, 455, 454, 453, 452, 451, 450, 449, 448, 447, 446, 445, 444, 443, 442, 441, 440, 439, 438, 437, 436, 435, 434, 433, 432, 431, 430, 429, 428, 427, 426, 425, 424, 423, 422, 421, 420, 419, 418, 417, 416, 415, 414, 413, 412, 411, 410, 409, 408, 407, 406, 405, 404, 403, 402, 401, 400, 399, 398, 397, 396, 395, 394, 393, 392, 391, 390, 389, 388, 387, 386, 385, 384, 383, 382, 381, 380, 379, 378, 377, 376, 375, 374, 373, 372, 371, 370, 369, 368, 367, 366, 365, 364, 363, 362, 361, 360, 359, 358, 357, 356, 355, 354, 353, 352, 351, 350, 349, 348, 347, 346, 345, 344, 343, 342, 341, 340, 339, 338, 337, 336, 335, 334, 333, 332, 331, 330, 329, 328, 327, 326, 325, 324, 323, 322, 321, 320, 319, 318, 317, 316, 315, 314, 313, 312, 311, 310, 309, 308, 307, 306, 305, 304, 303, 302, 301, 300, 299, 298, 297, 296, 295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 278, 277, 276, 275, 274, 273, 272, 271, 270, 269, 268, 267, 266, 265, 264, 263, 262, 261, 260, 259, 258, 257, 256, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153, 152, 151, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
  145|       |
  146|       |/// @cond MACROS
  147|       |#define EMP_dup_bin_0(...)
  148|      0|#define EMP_dup_bin_1(...) , __VA_ARGS__
  149|      0|#define EMP_dup_bin_2(...) , __VA_ARGS__, __VA_ARGS__
  150|      0|#define EMP_dup_bin_4(...) , __VA_ARGS__, __VA_ARGS__, __VA_ARGS__, __VA_ARGS__
  151|      0|#define EMP_dup_bin_8(...)   EMP_dup_bin_4(__VA_ARGS__)EMP_dup_bin_4(__VA_ARGS__)
  152|      0|#define EMP_dup_bin_16(...)  EMP_dup_bin_8(__VA_ARGS__)EMP_dup_bin_8(__VA_ARGS__)
  153|      0|#define EMP_dup_bin_32(...)  EMP_dup_bin_16(__VA_ARGS__)EMP_dup_bin_16(__VA_ARGS__)
  154|      0|#define EMP_dup_bin_64(...)  EMP_dup_bin_32(__VA_ARGS__)EMP_dup_bin_32(__VA_ARGS__)
  155|      0|#define EMP_dup_bin_128(...) EMP_dup_bin_64(__VA_ARGS__)EMP_dup_bin_64(__VA_ARGS__)
  156|      0|#define EMP_dup_bin_256(...) EMP_dup_bin_128(__VA_ARGS__)EMP_dup_bin_128(__VA_ARGS__)
  157|      0|#define EMP_dup_bin_512(...) EMP_dup_bin_256(__VA_ARGS__)EMP_dup_bin_256(__VA_ARGS__)
  158|       |/// @endcond
  159|       |
  160|       |/// makes N collated copies of all args to follow.
  161|      0|#define EMP_DUPLICATE_ARGS(N, ...) EMP_DUPLICATE_ARGS_SUM EMP_EMPTY() (EMP_EVAL(EMP_DEC_TO_SUM(N)),__VA_ARGS__)
  162|      0|#define EMP_DUPLICATE_ARGS_SUM(S0,S1,S2,S3,S4,S5,S6,S7,S8,S9,...) EMP_POP_ARG(~ EMP_dup_bin_##S0(__VA_ARGS__)EMP_dup_bin_##S1(__VA_ARGS__)EMP_dup_bin_##S2(__VA_ARGS__)EMP_dup_bin_##S3(__VA_ARGS__)EMP_dup_bin_##S4(__VA_ARGS__)EMP_dup_bin_##S5(__VA_ARGS__)EMP_dup_bin_##S6(__VA_ARGS__)EMP_dup_bin_##S7(__VA_ARGS__)EMP_dup_bin_##S8(__VA_ARGS__)EMP_dup_bin_##S9(__VA_ARGS__))
  163|       |
  164|       |
  165|       |// Some PARAMETER PACK manipulatation (for macros, sets of args in parens to they are treated
  166|       |// as if they were a single argument.
  167|       |
  168|      0|#define EMP_ECHO_ARGS(...) __VA_ARGS__
  169|       |/// Group args together in parens so they are treated like one argument.
  170|      0|#define EMP_PACK_ARGS(...) (__VA_ARGS__)
  171|      0|#define EMP_UNPACK_ARGS(A) EMP_ECHO_ARGS A
  172|       |
  173|      0|#define EMP_PACK_POP(PACK) (EMP_POP_ARG PACK)
  174|      0|#define EMP_PACK_TOP(PACK) EMP_GET_ARG_1 PACK
  175|      0|#define EMP_PACK_PUSH(NEW, PACK) (NEW,EMP_UNPACK_ARGS(PACK))
  176|      0|#define EMP_PACK_PUSH_REAR(NEW, PACK) (EMP_UNPACK_ARGS(PACK),NEW)
  177|      0|#define EMP_PACK_SIZE(PACK) EMP_COUNT_ARGS PACK
  178|       |
  179|       |// Macros to work on multiple packs at once.
  180|      0|#define EMP_PACKS_POP_ALL(...) EMP_WRAP_ARGS(EMP_PACK_POP, __VA_ARGS__)
  181|      0|#define EMP_PACKS_TOP_ALL(...) EMP_WRAP_ARGS(EMP_PACK_TOP, __VA_ARGS__)
  182|      0|#define EMP_PACKS_PUSH_ALL(NEW, ...) EMP_WRAP_ARGS_1ARG(EMP_PACK_PUSH, NEW, __VA_ARGS__)
  183|      0|#define EMP_PACKS_PUSH_REAR_ALL(NEW, ...) EMP_WRAP_ARGS_1ARG(EMP_PACK_PUSH_REAR, NEW, __VA_ARGS__)
  184|      0|#define EMP_PACKS_SIZE_ALL(...) EMP_WRAP_ARGS(EMP_PACK_SIZE, __VA_ARGS__)
  185|       |
  186|       |/// Group the arguments that follow into packs of size S.
  187|      0|#define EMP_ARGS_TO_PACKS(S, ...) \
  188|      0|  EMP_ARGS_TO_PACKS_impl(S, EMP_DIV(EMP_COUNT_ARGS(__VA_ARGS__), S), __VA_ARGS__)
  189|       |
  190|       |/// @cond MACROS
  191|       |// S = Size of each pack
  192|       |// N = Number of packs
  193|       |// P = Pack representatio of number of packs
  194|      0|#define EMP_ARGS_TO_PACKS_impl(S, N, ...) EMP_ARGS_TO_PACKS_implB(S, EMP_DEC_TO_PACK(N), __VA_ARGS)
  195|      0|#define EMP_ARGS_TO_PACKS_implB(S, P, ...) @CAO
  196|       |
  197|      0|#define EMP_ARGS_TO_PACKS_1(S, ...) , (EMP_CROP_ARGS_TO(S, __VA_ARGS__))
  198|      0|#define EMP_ARGS_TO_PACKS_2(S, ...)                                     \
  199|      0|  EMP_ARGS_TO_PACKS_1(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_1(S,EMP_POP(N, __VA_ARGS__))
  200|      0|#define EMP_ARGS_TO_PACKS_4(S, ...)                                     \
  201|      0|  EMP_ARGS_TO_PACKS_2(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_2(S,EMP_POP(EMP_MULT(N,2),__VA_ARGS__))
  202|      0|#define EMP_ARGS_TO_PACKS_8(S, ...)                                     \
  203|      0|  EMP_ARGS_TO_PACKS_4(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_4(S,EMP_POP(EMP_MULT(N,4),__VA_ARGS__))
  204|      0|#define EMP_ARGS_TO_PACKS_16(S, ...)                                    \
  205|      0|  EMP_ARGS_TO_PACKS_8(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_8(S,EMP_POP(EMP_MULT(N,8),__VA_ARGS__))
  206|      0|#define EMP_ARGS_TO_PACKS_32(S, ...)                                    \
  207|      0|  EMP_ARGS_TO_PACKS_16(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_16(S,EMP_POP(EMP_MULT(N,16),__VA_ARGS__))
  208|      0|#define EMP_ARGS_TO_PACKS_64(S, ...)                                    \
  209|      0|  EMP_ARGS_TO_PACKS_32(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_32(S,EMP_POP(EMP_MULT(N,32),__VA_ARGS__))
  210|      0|#define EMP_ARGS_TO_PACKS_128(S, ...)                                   \
  211|      0|  EMP_ARGS_TO_PACKS_64(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_64(S,EMP_POP(EMP_MULT(N,64),__VA_ARGS__))
  212|      0|#define EMP_ARGS_TO_PACKS_256(S, ...)                                   \
  213|      0|  EMP_ARGS_TO_PACKS_128(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_128(S,EMP_POP(EMP_MULT(N,128),__VA_ARGS__))
  214|      0|#define EMP_ARGS_TO_PACKS_512(S, ...)                                   \
  215|      0|  EMP_ARGS_TO_PACKS_256(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_256(S,EMP_POP(EMP_MULT(N,256),__VA_ARGS__))
  216|       |/// @endcond
  217|       |
  218|       |/// EMP_CALL_BY_PACKS is used to build other macros.  It will call a series of versions of C
  219|       |/// based on binary representations so that all args are called, passing F in as the first
  220|       |/// parameter.  For example, if C = ABC_ and 13 arguments are passed in, it will call ABC_8,
  221|       |/// ABC_4 and ABC_1 on appropriate subsets (prepending F as the first argument of each call)
  222|       |///
  223|       |/// C is the CALL needed to be made on each element of the parameter pack
  224|       |/// F is a FIXED parameter (potentially a pack) sent to all calls.
  225|      0|#define EMP_CALL_BY_PACKS(C, F, ...)                                     \
  226|      0|  EMP_CALL_BY_PACKS_impl(C, F, EMP_DEC_TO_PACK(EMP_COUNT_ARGS(__VA_ARGS__)), __VA_ARGS__, ~)
  227|       |
  228|       |/// @cond MACROS
  229|       |
  230|       |// Internal helpers...
  231|       |// P is the pack of call counts the still need to be done
  232|       |// A is the number of arguments in P.
  233|       |// N is the NEXT call count needed to be done.
  234|      0|#define EMP_CALL_BY_PACKS_impl(C, F, P, ...) \
  235|      0|  EMP_CALL_BY_PACKS_implB(C, F, EMP_PACK_SIZE(P), EMP_PACK_PUSH_REAR(~, P), __VA_ARGS__)
  236|      0|#define EMP_CALL_BY_PACKS_implB(C, F, A, P, ...) EMP_CALL_BY_PACKS_implC(C, F, A, P, __VA_ARGS__)
  237|      0|#define EMP_CALL_BY_PACKS_implC(C, F, A, P, ...) \
  238|      0|  EMP_CALL_BY_PACKS_implD(C, EMP_PACK_TOP(P), F, A, EMP_PACK_POP(P), __VA_ARGS__)
  239|      0|#define EMP_CALL_BY_PACKS_implD(C, N, F, A, P, ...) EMP_CALL_BY_PACKS_impl##A(C,N,F,P,__VA_ARGS__)
  240|       |
  241|      0|#define EMP_CALL_BY_PACKS_impl1(C, N, F, P, ...)        \
  242|      0|  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)
  243|       |
  244|      0|#define EMP_CALL_BY_PACKS_impl2(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl2B(C, N, F, P, __VA_ARGS__)
  245|      0|#define EMP_CALL_BY_PACKS_impl2B(C, N, F, P, ...)                       \
  246|      0|  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  247|      0|  EMP_CALL_BY_PACKS_impl1(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  248|       |
  249|      0|#define EMP_CALL_BY_PACKS_impl3(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl3B(C, N, F, P, __VA_ARGS__)
  250|      0|#define EMP_CALL_BY_PACKS_impl3B(C, N, F, P, ...)                       \
  251|      0|  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  252|      0|  EMP_CALL_BY_PACKS_impl2(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  253|       |
  254|      0|#define EMP_CALL_BY_PACKS_impl4(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl4B(C, N, F, P, __VA_ARGS__)
  255|      0|#define EMP_CALL_BY_PACKS_impl4B(C, N, F, P, ...)                       \
  256|      0|  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  257|      0|  EMP_CALL_BY_PACKS_impl3(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  258|       |
  259|      0|#define EMP_CALL_BY_PACKS_impl5(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl5B(C, N, F, P, __VA_ARGS__)
  260|      0|#define EMP_CALL_BY_PACKS_impl5B(C, N, F, P, ...)                       \
  261|      0|  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  262|      0|  EMP_CALL_BY_PACKS_impl4(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  263|       |
  264|      0|#define EMP_CALL_BY_PACKS_impl6(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl6B(C, N, F, P, __VA_ARGS__)
  265|      0|#define EMP_CALL_BY_PACKS_impl6B(C, N, F, P, ...)                       \
  266|      0|  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  267|      0|  EMP_CALL_BY_PACKS_impl5(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  268|       |
  269|      0|#define EMP_CALL_BY_PACKS_impl7(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl7B(C, N, F, P, __VA_ARGS__)
  270|      0|#define EMP_CALL_BY_PACKS_impl7B(C, N, F, P, ...)                       \
  271|      0|  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  272|      0|  EMP_CALL_BY_PACKS_impl6(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  273|       |
  274|      0|#define EMP_CALL_BY_PACKS_impl8(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl8B(C, N, F, P, __VA_ARGS__)
  275|      0|#define EMP_CALL_BY_PACKS_impl8B(C, N, F, P, ...)                       \
  276|      0|  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  277|      0|  EMP_CALL_BY_PACKS_impl7(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  278|       |
  279|      0|#define EMP_CALL_BY_PACKS_impl9(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl9B(C, N, F, P, __VA_ARGS__)
  280|      0|#define EMP_CALL_BY_PACKS_impl9B(C, N, F, P, ...)                       \
  281|      0|  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  282|      0|  EMP_CALL_BY_PACKS_impl8(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  283|       |
  284|      0|#define EMP_CALL_BY_PACKS_impl10(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl10B(C, N, F, P, __VA_ARGS__)
  285|      0|#define EMP_CALL_BY_PACKS_impl10B(C, N, F, P, ...)                      \
  286|      0|  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  287|      0|  EMP_CALL_BY_PACKS_impl9(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  288|       |
  289|      0|#define EMP_CALL_BY_PACKS_do_call(C, V, F, ...) C ## V(F, __VA_ARGS__)
  290|       |
  291|       |/// @endcond
  292|       |
  293|       |/// EMP_WRAP_EACH, wraps each argument in the specified macro wrapper.
  294|      0|#define EMP_WRAP_EACH(W, ...) EMP_CALL_BY_PACKS(EMP_WRAP_EACH_, W, __VA_ARGS__)
  295|       |/// @cond MACROS
  296|      0|#define EMP_WRAP_EACH_1(W, A, ...) W(A)
  297|      0|#define EMP_WRAP_EACH_2(W, A,B,...) EMP_WRAP_EACH_1(W, A, ~) EMP_WRAP_EACH_1(W, B, ~)
  298|      0|#define EMP_WRAP_EACH_4(W, A,B,...) EMP_WRAP_EACH_2(W, A, B, ~) EMP_WRAP_EACH_2(W, __VA_ARGS__)
  299|      0|#define EMP_WRAP_EACH_8(W, ...)                                         \
  300|      0|  EMP_WRAP_EACH_4(W, __VA_ARGS__)                                       \
  301|      0|  EMP_EVAL1( EMP_WRAP_EACH_4 EMP_EMPTY() (W, EMP_POP_ARGS_4(__VA_ARGS__)) )
  302|      0|#define EMP_WRAP_EACH_16(W, ...) \
  303|      0|  EMP_WRAP_EACH_8(W, __VA_ARGS__) \
  304|      0|  EMP_EVAL2( EMP_WRAP_EACH_8 EMP_EMPTY() (W, EMP_POP_ARGS_8(__VA_ARGS__)) )
  305|      0|#define EMP_WRAP_EACH_32(W, ...) \
  306|      0|  EMP_WRAP_EACH_16(W, __VA_ARGS__) \
  307|      0|  EMP_EVAL3( EMP_WRAP_EACH_16 EMP_EMPTY() (W, EMP_POP_ARGS_16(__VA_ARGS__)) )
  308|      0|#define EMP_WRAP_EACH_64(W, ...) \
  309|      0|  EMP_WRAP_EACH_32(W, __VA_ARGS__) \
  310|      0|  EMP_EVAL4( EMP_WRAP_EACH_32 EMP_EMPTY() (W, EMP_POP_ARGS_32(__VA_ARGS__)) )
  311|      0|#define EMP_WRAP_EACH_128(W, ...) \
  312|      0|  EMP_WRAP_EACH_64(W, __VA_ARGS__) \
  313|      0|  EMP_EVAL5( EMP_WRAP_EACH_64 EMP_EMPTY() (W, EMP_POP_ARGS_64(__VA_ARGS__)) )
  314|      0|#define EMP_WRAP_EACH_256(W, ...) \
  315|      0|  EMP_WRAP_EACH_128(W, __VA_ARGS__) \
  316|      0|  EMP_EVAL6( EMP_WRAP_EACH_128 EMP_EMPTY() (W, EMP_POP_ARGS_128(__VA_ARGS__)) )
  317|      0|#define EMP_WRAP_EACH_512(W, ...) \
  318|      0|  EMP_WRAP_EACH_256(W, __VA_ARGS__) \
  319|      0|  EMP_EVAL7( EMP_WRAP_EACH_256 EMP_EMPTY() (W, EMP_POP_ARGS_256(__VA_ARGS__)) )
  320|       |/// @endcond
  321|       |
  322|       |/// EMP_WRAP_EACH_1ARG, wraps each argument in the specified macro wrapper, with added first arg.
  323|      0|#define EMP_WRAP_EACH_1ARG(W, ARG, ...) EMP_CALL_BY_PACKS(EMP_WRAP_EACH_1ARG_, (W, ARG), __VA_ARGS__)
  324|       |/// @cond MACROS
  325|      0|#define EMP_WRAP_EACH_1ARG_1(P, A, ...) EMP_GET_ARG_1 P (EMP_GET_ARG_2 P, A)
  326|      0|#define EMP_WRAP_EACH_1ARG_2(P, A,B,...) EMP_WRAP_EACH_1ARG_1(P, A, ~)         \
  327|      0|                                              EMP_WRAP_EACH_1ARG_1(P, B, ~)
  328|      0|#define EMP_WRAP_EACH_1ARG_4(P, A,B,...) EMP_WRAP_EACH_1ARG_2(P, A, B, ~)      \
  329|      0|                                              EMP_WRAP_EACH_1ARG_2(P, __VA_ARGS__)
  330|      0|#define EMP_WRAP_EACH_1ARG_8(P, ...)                                                \
  331|      0|  EMP_WRAP_EACH_1ARG_4(P, __VA_ARGS__)                                              \
  332|      0|  EMP_EVAL1( EMP_WRAP_EACH_1ARG_4 EMP_EMPTY() (P, EMP_POP_ARGS_4(__VA_ARGS__)) )
  333|      0|#define EMP_WRAP_EACH_1ARG_16(P, ...)                                               \
  334|      0|  EMP_WRAP_EACH_1ARG_8(P, __VA_ARGS__)                                              \
  335|      0|  EMP_EVAL2( EMP_WRAP_EACH_1ARG_8 EMP_EMPTY() (P, EMP_POP_ARGS_8(__VA_ARGS__)) )
  336|      0|#define EMP_WRAP_EACH_1ARG_32(P, ...)                                               \
  337|      0|  EMP_WRAP_EACH_1ARG_16(P, __VA_ARGS__)                                             \
  338|      0|  EMP_EVAL3( EMP_WRAP_EACH_1ARG_16 EMP_EMPTY() (P, EMP_POP_ARGS_16(__VA_ARGS__)) )
  339|      0|#define EMP_WRAP_EACH_1ARG_64(P, ...)                                               \
  340|      0|  EMP_WRAP_EACH_1ARG_32(P, __VA_ARGS__)                                             \
  341|      0|  EMP_EVAL4( EMP_WRAP_EACH_1ARG_32 EMP_EMPTY() (P, EMP_POP_ARGS_32(__VA_ARGS__)) )
  342|      0|#define EMP_WRAP_EACH_1ARG_128(P, ...)                                              \
  343|      0|  EMP_WRAP_EACH_1ARG_64(P, __VA_ARGS__)                                             \
  344|      0|  EMP_EVAL5( EMP_WRAP_EACH_1ARG_64 EMP_EMPTY() (P, EMP_POP_ARGS_64(__VA_ARGS__)) )
  345|      0|#define EMP_WRAP_EACH_1ARG_256(P, ...)                                              \
  346|      0|  EMP_WRAP_EACH_1ARG_128(P, __VA_ARGS__)                                            \
  347|      0|  EMP_EVAL6( EMP_WRAP_EACH_1ARG_128 EMP_EMPTY() (P, EMP_POP_ARGS_128(__VA_ARGS__)) )
  348|      0|#define EMP_WRAP_EACH_1ARG_512(P, ...)                                              \
  349|      0|  EMP_WRAP_EACH_1ARG_256(P, __VA_ARGS__)                                            \
  350|      0|  EMP_EVAL7( EMP_WRAP_EACH_1ARG_256 EMP_EMPTY() (P, EMP_POP_ARGS_256(__VA_ARGS__)) )
  351|       |/// @endcond
  352|       |
  353|       |/// imilar to EMP_WRAP_EACH, but puts a COMMA between each arg pair.
  354|      2|#define EMP_WRAP_ARGS(W, ...) EMP_POP_ARGS_1( ~ EMP_CALL_BY_PACKS(EMP_WRAP_ARGS_, W, __VA_ARGS__) )
  355|       |/// @cond MACROS
  356|      0|#define EMP_WRAP_ARGS_1(W, A, ...) , W(A)
  357|      0|#define EMP_WRAP_ARGS_2(W, A,B,...) EMP_WRAP_ARGS_1(W, A, ~) EMP_WRAP_ARGS_1(W, B, ~)
  358|      0|#define EMP_WRAP_ARGS_4(W, A,B,...) EMP_WRAP_ARGS_2(W, A, B, ~) EMP_WRAP_ARGS_2(W, __VA_ARGS__)
  359|      0|#define EMP_WRAP_ARGS_8(W, ...)                                         \
  360|      0|  EMP_WRAP_ARGS_4(W, __VA_ARGS__)                                       \
  361|      0|  EMP_EVAL1( EMP_WRAP_ARGS_4 EMP_EMPTY() (W, EMP_POP_ARGS_4(__VA_ARGS__)) )
  362|      0|#define EMP_WRAP_ARGS_16(W, ...) \
  363|      0|  EMP_WRAP_ARGS_8(W, __VA_ARGS__) \
  364|      0|  EMP_EVAL2( EMP_WRAP_ARGS_8 EMP_EMPTY() (W, EMP_POP_ARGS_8(__VA_ARGS__)) )
  365|      0|#define EMP_WRAP_ARGS_32(W, ...) \
  366|      0|  EMP_WRAP_ARGS_16(W, __VA_ARGS__) \
  367|      0|  EMP_EVAL3( EMP_WRAP_ARGS_16 EMP_EMPTY() (W, EMP_POP_ARGS_16(__VA_ARGS__)) )
  368|      0|#define EMP_WRAP_ARGS_64(W, ...) \
  369|      0|  EMP_WRAP_ARGS_32(W, __VA_ARGS__) \
  370|      0|  EMP_EVAL4( EMP_WRAP_ARGS_32 EMP_EMPTY() (W, EMP_POP_ARGS_32(__VA_ARGS__)) )
  371|      0|#define EMP_WRAP_ARGS_128(W, ...) \
  372|      0|  EMP_WRAP_ARGS_64(W, __VA_ARGS__) \
  373|      0|  EMP_EVAL5( EMP_WRAP_ARGS_64 EMP_EMPTY() (W, EMP_POP_ARGS_64(__VA_ARGS__)) )
  374|      0|#define EMP_WRAP_ARGS_256(W, ...) \
  375|      0|  EMP_WRAP_ARGS_128(W, __VA_ARGS__) \
  376|      0|  EMP_EVAL6( EMP_WRAP_ARGS_128 EMP_EMPTY() (W, EMP_POP_ARGS_128(__VA_ARGS__)) )
  377|      0|#define EMP_WRAP_ARGS_512(W, ...) \
  378|      0|  EMP_WRAP_ARGS_256(W, __VA_ARGS__) \
  379|      0|  EMP_EVAL7( EMP_WRAP_ARGS_256 EMP_EMPTY() (W, EMP_POP_ARGS_256(__VA_ARGS__)) )
  380|       |/// @endcond
  381|       |
  382|      0|#define EMP_WRAP_ARGS_1ARG(W, ARG, ...) \
  383|      0|  EMP_POP_ARGS_1( ~ EMP_CALL_BY_PACKS(EMP_WRAP_ARGS_1ARG_, (W, ARG), __VA_ARGS__) )
  384|       |/// @cond MACROS
  385|      0|#define EMP_WRAP_ARGS_1ARG_1(P, A, ...) , EMP_GET_ARG_1 P (EMP_GET_ARG_2 P, A)
  386|      0|#define EMP_WRAP_ARGS_1ARG_2(P, A,B,...) EMP_WRAP_ARGS_1ARG_1(P, A, ~) EMP_WRAP_ARGS_1ARG_1(P, B, ~)
  387|      0|#define EMP_WRAP_ARGS_1ARG_4(P, A,B,...) EMP_WRAP_ARGS_1ARG_2(P, A, B, ~) EMP_WRAP_ARGS_1ARG_2(P, __VA_ARGS__)
  388|      0|#define EMP_WRAP_ARGS_1ARG_8(P, ...)                                         \
  389|      0|  EMP_WRAP_ARGS_1ARG_4(P, __VA_ARGS__)                                       \
  390|      0|  EMP_EVAL1( EMP_WRAP_ARGS_1ARG_4 EMP_EMPTY() (P, EMP_POP_ARGS_4(__VA_ARGS__)) )
  391|      0|#define EMP_WRAP_ARGS_1ARG_16(P, ...) \
  392|      0|  EMP_WRAP_ARGS_1ARG_8(P, __VA_ARGS__) \
  393|      0|  EMP_EVAL2( EMP_WRAP_ARGS_1ARG_8 EMP_EMPTY() (P, EMP_POP_ARGS_8(__VA_ARGS__)) )
  394|      0|#define EMP_WRAP_ARGS_1ARG_32(P, ...) \
  395|      0|  EMP_WRAP_ARGS_1ARG_16(P, __VA_ARGS__) \
  396|      0|  EMP_EVAL3( EMP_WRAP_ARGS_1ARG_16 EMP_EMPTY() (P, EMP_POP_ARGS_16(__VA_ARGS__)) )
  397|      0|#define EMP_WRAP_ARGS_1ARG_64(P, ...) \
  398|      0|  EMP_WRAP_ARGS_1ARG_32(P, __VA_ARGS__) \
  399|      0|  EMP_EVAL4( EMP_WRAP_ARGS_1ARG_32 EMP_EMPTY() (P, EMP_POP_ARGS_32(__VA_ARGS__)) )
  400|      0|#define EMP_WRAP_ARGS_1ARG_128(P, ...) \
  401|      0|  EMP_WRAP_ARGS_1ARG_64(P, __VA_ARGS__) \
  402|      0|  EMP_EVAL5( EMP_WRAP_ARGS_1ARG_64 EMP_EMPTY() (P, EMP_POP_ARGS_64(__VA_ARGS__)) )
  403|      0|#define EMP_WRAP_ARGS_1ARG_256(P, ...) \
  404|      0|  EMP_WRAP_ARGS_1ARG_128(P, __VA_ARGS__) \
  405|      0|  EMP_EVAL6( EMP_WRAP_ARGS_1ARG_128 EMP_EMPTY() (P, EMP_POP_ARGS_128(__VA_ARGS__)) )
  406|      0|#define EMP_WRAP_ARGS_1ARG_512(P, ...) \
  407|      0|  EMP_WRAP_ARGS_1ARG_256(P, __VA_ARGS__) \
  408|      0|  EMP_EVAL7( EMP_WRAP_ARGS_1ARG_256 EMP_EMPTY() (P, EMP_POP_ARGS_256(__VA_ARGS__)) )
  409|       |/// @endcond
  410|       |
  411|       |/// Replace all of the commas in an argument set with something else (including nothing)
  412|       |/// @cond MACROS
  413|      0|#define EMP_REMOVE_COMMAS(...) EMP_REPLACE_COMMAS(,__VA_ARGS__)
  414|       |/// @endcond
  415|      0|#define EMP_REPLACE_COMMAS(X, ...) EMP_GET_ARG_1(__VA_ARGS__) EMP_CALL_BY_PACKS(EMP_REPLACE_COMMAS_, X, EMP_POP_ARGS_1(__VA_ARGS__) )
  416|       |
  417|       |/// @cond MACROS
  418|      0|#define EMP_REPLACE_COMMAS_1(X, A, ...) X A
  419|      0|#define EMP_REPLACE_COMMAS_2(X, A,B, ...) X A X B
  420|      0|#define EMP_REPLACE_COMMAS_4(X, A,B,C,D, ...) X A X B X C X D
  421|      0|#define EMP_REPLACE_COMMAS_8(X, A,B,C,D,E,F,G,H, ...) X A X B X C X D X E X F X G X H
  422|      0|#define EMP_REPLACE_COMMAS_16(X, ...) \
  423|      0|  EMP_REPLACE_COMMAS_8(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_8(__VA_ARGS__) )
  424|      0|#define EMP_REPLACE_COMMAS_32(X, ...) \
  425|      0|  EMP_REPLACE_COMMAS_16(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_16(__VA_ARGS__) )
  426|      0|#define EMP_REPLACE_COMMAS_64(X, ...) \
  427|      0|  EMP_REPLACE_COMMAS_32(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_32(__VA_ARGS__) )
  428|      0|#define EMP_REPLACE_COMMAS_128(X, ...) \
  429|      0|  EMP_REPLACE_COMMAS_64(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_64(__VA_ARGS__) )
  430|      0|#define EMP_REPLACE_COMMAS_256(X, ...) \
  431|      0|  EMP_REPLACE_COMMAS_128(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_128(__VA_ARGS__) )
  432|      0|#define EMP_REPLACE_COMMAS_512(X, ...) \
  433|      0|  EMP_REPLACE_COMMAS_256(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_256(__VA_ARGS__) )
  434|       |/// @endcond
  435|       |
  436|       |/// Keep only the first N args (assumes at least N args exist!)
  437|      0|#define EMP_CROP_ARGS_TO(N, ...) EMP_POP_ARG(~ EMP_CALL_BY_PACKS_impl(EMP_CROP_ARGS_TO_, ~, EMP_DEC_TO_PACK(N), __VA_ARGS__, ~))
  438|       |/// @cond MACROS
  439|      0|#define EMP_CROP_ARGS_TO_1(W, A, ...) , A
  440|      0|#define EMP_CROP_ARGS_TO_2(W, A,B,...) , A , B
  441|      0|#define EMP_CROP_ARGS_TO_4(W, A,B,...) EMP_CROP_ARGS_TO_2(W, A,B,~) EMP_CROP_ARGS_TO_2(W,__VA_ARGS__)
  442|      0|#define EMP_CROP_ARGS_TO_8(W, ...) EMP_CROP_ARGS_TO_4(W, __VA_ARGS__) EMP_EVAL1( EMP_CROP_ARGS_TO_4 EMP_EMPTY() (W, EMP_POP_ARGS_4(__VA_ARGS__)) )
  443|      0|#define EMP_CROP_ARGS_TO_16(W, ...) EMP_CROP_ARGS_TO_8(W, __VA_ARGS__) EMP_EVAL2( EMP_CROP_ARGS_TO_8 EMP_EMPTY() (W, EMP_POP_ARGS_8(__VA_ARGS__)) )
  444|      0|#define EMP_CROP_ARGS_TO_32(W, ...) EMP_CROP_ARGS_TO_16(W, __VA_ARGS__) EMP_EVAL3( EMP_CROP_ARGS_TO_16 EMP_EMPTY() (W, EMP_POP_ARGS_16(__VA_ARGS__)) )
  445|      0|#define EMP_CROP_ARGS_TO_64(W, ...) EMP_CROP_ARGS_TO_32(W, __VA_ARGS__) EMP_EVAL4( EMP_CROP_ARGS_TO_32 EMP_EMPTY() (W, EMP_POP_ARGS_32(__VA_ARGS__)) )
  446|      0|#define EMP_CROP_ARGS_TO_128(W, ...) EMP_CROP_ARGS_TO_64(W, __VA_ARGS__) EMP_EVAL5( EMP_CROP_ARGS_TO_64 EMP_EMPTY() (W, EMP_POP_ARGS_64(__VA_ARGS__)) )
  447|      0|#define EMP_CROP_ARGS_TO_256(W, ...) EMP_CROP_ARGS_TO_128(W, __VA_ARGS__) EMP_EVAL6( EMP_CROP_ARGS_TO_128 EMP_EMPTY() (W, EMP_POP_ARGS_128(__VA_ARGS__)) )
  448|      0|#define EMP_CROP_ARGS_TO_512(W, ...) EMP_CROP_ARGS_TO_256(W, __VA_ARGS__) EMP_EVAL7( EMP_CROP_ARGS_TO_256 EMP_EMPTY() (W, EMP_POP_ARGS_256(__VA_ARGS__)) )
  449|       |/// @endcond
  450|       |
  451|       |/// Force arguments to a specific number.  If less, pad them; if more crop them.
  452|      0|#define EMP_FORCE_ARGS_TO(N, PAD, ...) EMP_CROP_ARGS_TO(N, __VA_ARGS__, EMP_DUPLICATE_ARGS(N, PAD))
  453|       |
  454|      0|#define EMP_ROTATE_ARGS(A, ...) __VA_ARGS__, A
  455|      0|#define EMP_RUN_JOIN(A, B) A B
  456|       |
  457|      0|#define EMP_PERMUTE(...) EMP_ASSEMBLE_MACRO(EMP_PERMUTE_, __VA_ARGS__)
  458|       |/// @cond MACROS
  459|      0|#define EMP_PERMUTE_1(A1) (A1)
  460|      0|#define EMP_PERMUTE_2(A1,A2) (A1,A2),(A2,A1)
  461|      0|#define EMP_PERMUTE_3(A1,A2,A3) (A1,A2,A3),(A2,A1,A3),(A1,A3,A2),(A2,A3,A1),(A3,A1,A2),(A3,A2,A1)
  462|      0|#define EMP_PERMUTE_4(A1,A2,A3,A4) EMP_PACKS_PUSH_ALL(A1, EMP_PERMUTE_3(A2,A3,A4)), \
  463|      0|                                   EMP_PACKS_PUSH_ALL(A2, EMP_PERMUTE_3(A1,A3,A4)), \
  464|      0|                                   EMP_PACKS_PUSH_ALL(A3, EMP_PERMUTE_3(A1,A2,A4)), \
  465|      0|                                   EMP_PACKS_PUSH_ALL(A4, EMP_PERMUTE_3(A1,A2,A3))
  466|      0|#define EMP_PERMUTE_5(A1,A2,A3,A4,A5) EMP_PACKS_PUSH_ALL(A1, EMP_PERMUTE_4(A2,A3,A4,A5)), \
  467|      0|                                      EMP_PACKS_PUSH_ALL(A2, EMP_PERMUTE_4(A1,A3,A4,A5)), \
  468|      0|                                      EMP_PACKS_PUSH_ALL(A3, EMP_PERMUTE_4(A1,A2,A4,A5)), \
  469|      0|                                      EMP_PACKS_PUSH_ALL(A4, EMP_PERMUTE_4(A1,A2,A3,A5)), \
  470|      0|                                      EMP_PACKS_PUSH_ALL(A5, EMP_PERMUTE_4(A1,A2,A3,A4))
  471|       |///@endcond
  472|       |
  473|       |/// A generic technique to trim the arguments we have.  In parens, list i or x for each
  474|       |/// position and whether it should be included or excluded.  For example
  475|       |///
  476|       |/// EMP_SELECT_ARGS( (i,x,x,i,i), 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 )
  477|       |///
  478|       |/// ... would return:
  479|       |///
  480|       |/// 1,4,5,6,9,10,11,14,15
  481|       |
  482|      0|#define EMP_SELECT_i(A, ...) , A
  483|       |#define EMP_SELECT_x(A, ...)
  484|       |
  485|      0|#define EMP_SELECT_do_arg(P, A) EMP_IMERGE_2(EMP_SELECT_, EMP_RUN_JOIN(EMP_GET_ARG_1, P))(A,~)
  486|       |
  487|      0|#define EMP_SELECT_ARGS(PATTERN, ...) EMP_POP_ARG( ~ EMP_ASSEMBLE_MACRO_1ARG(EMP_SELECT_ARGS_, PATTERN, __VA_ARGS__) )
  488|       |
  489|       |/// @cond MACROS
  490|      0|#define EMP_SELECT_ARGS_1(P, A) EMP_SELECT_do_arg(P, A)
  491|      0|#define EMP_SELECT_ARGS_2(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_1( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  492|      0|#define EMP_SELECT_ARGS_3(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_2( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  493|      0|#define EMP_SELECT_ARGS_4(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_3( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  494|      0|#define EMP_SELECT_ARGS_5(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_4( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  495|      0|#define EMP_SELECT_ARGS_6(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_5( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  496|      0|#define EMP_SELECT_ARGS_7(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_6( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  497|      0|#define EMP_SELECT_ARGS_8(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_7( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  498|      0|#define EMP_SELECT_ARGS_9(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_8( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  499|      0|#define EMP_SELECT_ARGS_10(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_9( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  500|      0|#define EMP_SELECT_ARGS_11(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_10( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  501|      0|#define EMP_SELECT_ARGS_12(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_11( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  502|      0|#define EMP_SELECT_ARGS_13(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_12( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  503|      0|#define EMP_SELECT_ARGS_14(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_13( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  504|      0|#define EMP_SELECT_ARGS_15(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_14( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  505|      0|#define EMP_SELECT_ARGS_16(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_15( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  506|      0|#define EMP_SELECT_ARGS_17(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_16( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  507|      0|#define EMP_SELECT_ARGS_18(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_17( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  508|      0|#define EMP_SELECT_ARGS_19(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_18( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  509|      0|#define EMP_SELECT_ARGS_20(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_19( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  510|      0|#define EMP_SELECT_ARGS_21(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_20( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  511|      0|#define EMP_SELECT_ARGS_22(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_21( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  512|      0|#define EMP_SELECT_ARGS_23(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_22( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  513|      0|#define EMP_SELECT_ARGS_24(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_23( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  514|      0|#define EMP_SELECT_ARGS_25(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_24( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  515|      0|#define EMP_SELECT_ARGS_26(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_25( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  516|      0|#define EMP_SELECT_ARGS_27(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_26( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  517|      0|#define EMP_SELECT_ARGS_28(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_27( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  518|      0|#define EMP_SELECT_ARGS_29(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_28( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  519|      0|#define EMP_SELECT_ARGS_30(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_29( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  520|      0|#define EMP_SELECT_ARGS_31(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_30( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  521|      0|#define EMP_SELECT_ARGS_32(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_31( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  522|      0|#define EMP_SELECT_ARGS_33(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_32( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  523|      0|#define EMP_SELECT_ARGS_34(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_33( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  524|      0|#define EMP_SELECT_ARGS_35(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_34( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  525|      0|#define EMP_SELECT_ARGS_36(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_35( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  526|      0|#define EMP_SELECT_ARGS_37(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_36( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  527|      0|#define EMP_SELECT_ARGS_38(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_37( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  528|      0|#define EMP_SELECT_ARGS_39(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_38( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  529|      0|#define EMP_SELECT_ARGS_40(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_39( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  530|      0|#define EMP_SELECT_ARGS_41(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_40( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  531|      0|#define EMP_SELECT_ARGS_42(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_41( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  532|      0|#define EMP_SELECT_ARGS_43(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_42( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  533|      0|#define EMP_SELECT_ARGS_44(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_43( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  534|      0|#define EMP_SELECT_ARGS_45(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_44( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  535|      0|#define EMP_SELECT_ARGS_46(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_45( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  536|      0|#define EMP_SELECT_ARGS_47(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_46( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  537|      0|#define EMP_SELECT_ARGS_48(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_47( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  538|      0|#define EMP_SELECT_ARGS_49(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_48( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  539|      0|#define EMP_SELECT_ARGS_50(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_49( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  540|      0|#define EMP_SELECT_ARGS_51(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_50( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  541|      0|#define EMP_SELECT_ARGS_52(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_51( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  542|      0|#define EMP_SELECT_ARGS_53(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_52( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  543|      0|#define EMP_SELECT_ARGS_54(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_53( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  544|      0|#define EMP_SELECT_ARGS_55(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_54( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  545|      0|#define EMP_SELECT_ARGS_56(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_55( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  546|      0|#define EMP_SELECT_ARGS_57(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_56( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  547|      0|#define EMP_SELECT_ARGS_58(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_57( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  548|      0|#define EMP_SELECT_ARGS_59(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_58( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  549|      0|#define EMP_SELECT_ARGS_60(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_59( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  550|      0|#define EMP_SELECT_ARGS_61(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_60( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  551|      0|#define EMP_SELECT_ARGS_62(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_61( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  552|      0|#define EMP_SELECT_ARGS_63(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_62( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  553|      0|#define EMP_SELECT_ARGS_64(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_63( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  554|      0|#define EMP_SELECT_ARGS_65(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_64( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  555|      0|#define EMP_SELECT_ARGS_66(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_65( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  556|      0|#define EMP_SELECT_ARGS_67(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_66( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  557|      0|#define EMP_SELECT_ARGS_68(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_67( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  558|      0|#define EMP_SELECT_ARGS_69(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_68( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  559|       |/// @endcond
  560|       |
  561|       |/// Get all even numbered args
  562|      0|#define EMP_GET_EVEN_ARGS(...) EMP_SELECT_ARGS((x,i), __VA_ARGS__)
  563|       |/// Get all odd numbered args
  564|      0|#define EMP_GET_ODD_ARGS(...) EMP_SELECT_ARGS((i,x), __VA_ARGS__)
  565|       |
  566|       |
  567|       |/// Enable an arbitrary number of arguments (well, up to 10) to be merged BEFORE being processed!
  568|      0|#define EMP_MERGE(...) EMP_ASSEMBLE_MACRO(EMP_MERGE_, __VA_ARGS__)
  569|       |
  570|       |/// Enable an arbitrary number of arguments (well, up to 10) to be INDIRECTLY merged, that is,
  571|       |/// AFTER being processed!
  572|      0|#define EMP_IMERGE(...) EMP_ASSEMBLE_MACRO(EMP_IMERGE_, __VA_ARGS__)
  573|       |
  574|       |/// @cond MACROS
  575|      0|#define EMP_MERGE_1(A1) A1
  576|      0|#define EMP_MERGE_2(A1,A2) A1 ## A2
  577|      0|#define EMP_MERGE_3(A1,A2,A3) A1 ## A2 ## A3
  578|      0|#define EMP_MERGE_4(A1,A2,A3,A4) A1 ## A2 ## A3 ## A4
  579|      0|#define EMP_MERGE_5(A1,A2,A3,A4,A5) A1 ## A2 ## A3 ## A4 ## A5
  580|      0|#define EMP_MERGE_6(A1,A2,A3,A4,A5,A6) A1 ## A2 ## A3 ## A4 ## A5 ## A6
  581|      0|#define EMP_MERGE_7(A1,A2,A3,A4,A5,A6,A7) A1 ## A2 ## A3 ## A4 ## A5 ## A6 ## A7
  582|      0|#define EMP_MERGE_8(A1,A2,A3,A4,A5,A6,A7,A8) A1 ## A2 ## A3 ## A4 ## A5 ## A6 ## A7 ## A8
  583|      0|#define EMP_MERGE_9(A1,A2,A3,A4,A5,A6,A7,A8,A9) A1 ## A2 ## A3 ## A4 ## A5 ## A6 ## A7 ## A8 ## A9
  584|      0|#define EMP_MERGE_10(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10) A1 ## A2 ## A3 ## A4 ## A5 ## A6 ## A7 ## A8 ## A9 ## A10
  585|       |
  586|       |// Indirect merges to give a chance for arg evaluation...
  587|       |
  588|      0|#define EMP_IMERGE_1(A1) EMP_MERGE_1(A1)
  589|      0|#define EMP_IMERGE_2(A1,A2) EMP_MERGE_2(A1, A2)
  590|      0|#define EMP_IMERGE_3(A1,A2,A3) EMP_MERGE_3(A1, A2, A3)
  591|      0|#define EMP_IMERGE_4(A1,A2,A3,A4) EMP_MERGE_4(A1, A2, A3, A4)
  592|      0|#define EMP_IMERGE_5(A1,A2,A3,A4,A5) EMP_MERGE_5(A1, A2, A3, A4, A5)
  593|      0|#define EMP_IMERGE_6(A1,A2,A3,A4,A5,A6) EMP_MERGE_6(A1, A2, A3, A4, A5, A6)
  594|      0|#define EMP_IMERGE_7(A1,A2,A3,A4,A5,A6,A7) EMP_MERGE_7(A1, A2, A3, A4, A5, A6, A7)
  595|      0|#define EMP_IMERGE_8(A1,A2,A3,A4,A5,A6,A7,A8) EMP_MERGE_8(A1, A2, A3, A4, A5, A6, A7, A8)
  596|      0|#define EMP_IMERGE_9(A1,A2,A3,A4,A5,A6,A7,A8,A9) EMP_MERGE_9(A1, A2, A3, A4, A5, A6, A7, A8, A9)
  597|      0|#define EMP_IMERGE_10(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10) EMP_MERGE_10(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
  598|       |
  599|       |/// @endcond
  600|       |
  601|       |// EMP_WRAP_EACH takes a wrapper macro and a variable set of arguments,
  602|       |// then applied to wrapper macro to each argument in order.
  603|       |//#define EMP_WRAP_EACH(W, ...) EMP_ASSEMBLE_MACRO_2ARG(EMP_LAYOUT_, W, , __VA_ARGS__)
  604|       |
  605|       |/// Similar to EMP_WRAP_EACH, but puts a P between each arg pair.
  606|       |/// EMP_LAYOUT takes a wrapper macro and padding information, wraps each argument in the macro
  607|       |/// and then spaces them out with the padding.
  608|       |/// W = Wrapper macro name, P = Padding between results
  609|      0|#define EMP_LAYOUT(W, P, ...) EMP_ASSEMBLE_MACRO_2ARG(EMP_LAYOUT_, W, P, __VA_ARGS__)
  610|       |/// @cond MACROS
  611|       |#define EMP_LAYOUT_0(W, P)
  612|      0|#define EMP_LAYOUT_1(W, P, A) W(A)
  613|      0|#define EMP_LAYOUT_2(W, P, A, ...) W(A) P EMP_LAYOUT_1(W, P, __VA_ARGS__)
  614|      0|#define EMP_LAYOUT_3(W, P, A, ...) W(A) P EMP_LAYOUT_2(W, P, __VA_ARGS__)
  615|      0|#define EMP_LAYOUT_4(W, P, A, ...) W(A) P EMP_LAYOUT_3(W, P, __VA_ARGS__)
  616|      0|#define EMP_LAYOUT_5(W, P, A, ...) W(A) P EMP_LAYOUT_4(W, P, __VA_ARGS__)
  617|      0|#define EMP_LAYOUT_6(W, P, A, ...) W(A) P EMP_LAYOUT_5(W, P, __VA_ARGS__)
  618|      0|#define EMP_LAYOUT_7(W, P, A, ...) W(A) P EMP_LAYOUT_6(W, P, __VA_ARGS__)
  619|      0|#define EMP_LAYOUT_8(W, P, A, ...) W(A) P EMP_LAYOUT_7(W, P, __VA_ARGS__)
  620|      0|#define EMP_LAYOUT_9(W, P, A, ...) W(A) P EMP_LAYOUT_8(W, P, __VA_ARGS__)
  621|      0|#define EMP_LAYOUT_10(W, P, A, ...) W(A) P EMP_LAYOUT_9(W, P, __VA_ARGS__)
  622|      0|#define EMP_LAYOUT_11(W, P, A, ...) W(A) P EMP_LAYOUT_10(W, P, __VA_ARGS__)
  623|      0|#define EMP_LAYOUT_12(W, P, A, ...) W(A) P EMP_LAYOUT_11(W, P, __VA_ARGS__)
  624|      0|#define EMP_LAYOUT_13(W, P, A, ...) W(A) P EMP_LAYOUT_12(W, P, __VA_ARGS__)
  625|      0|#define EMP_LAYOUT_14(W, P, A, ...) W(A) P EMP_LAYOUT_13(W, P, __VA_ARGS__)
  626|      0|#define EMP_LAYOUT_15(W, P, A, ...) W(A) P EMP_LAYOUT_14(W, P, __VA_ARGS__)
  627|      0|#define EMP_LAYOUT_16(W, P, A, ...) W(A) P EMP_LAYOUT_15(W, P, __VA_ARGS__)
  628|      0|#define EMP_LAYOUT_17(W, P, A, ...) W(A) P EMP_LAYOUT_16(W, P, __VA_ARGS__)
  629|      0|#define EMP_LAYOUT_18(W, P, A, ...) W(A) P EMP_LAYOUT_17(W, P, __VA_ARGS__)
  630|      0|#define EMP_LAYOUT_19(W, P, A, ...) W(A) P EMP_LAYOUT_18(W, P, __VA_ARGS__)
  631|      0|#define EMP_LAYOUT_20(W, P, A, ...) W(A) P EMP_LAYOUT_19(W, P, __VA_ARGS__)
  632|      0|#define EMP_LAYOUT_21(W, P, A, ...) W(A) P EMP_LAYOUT_20(W, P, __VA_ARGS__)
  633|      0|#define EMP_LAYOUT_22(W, P, A, ...) W(A) P EMP_LAYOUT_21(W, P, __VA_ARGS__)
  634|      0|#define EMP_LAYOUT_23(W, P, A, ...) W(A) P EMP_LAYOUT_22(W, P, __VA_ARGS__)
  635|      0|#define EMP_LAYOUT_24(W, P, A, ...) W(A) P EMP_LAYOUT_23(W, P, __VA_ARGS__)
  636|      0|#define EMP_LAYOUT_25(W, P, A, ...) W(A) P EMP_LAYOUT_24(W, P, __VA_ARGS__)
  637|      0|#define EMP_LAYOUT_26(W, P, A, ...) W(A) P EMP_LAYOUT_25(W, P, __VA_ARGS__)
  638|      0|#define EMP_LAYOUT_27(W, P, A, ...) W(A) P EMP_LAYOUT_26(W, P, __VA_ARGS__)
  639|      0|#define EMP_LAYOUT_28(W, P, A, ...) W(A) P EMP_LAYOUT_27(W, P, __VA_ARGS__)
  640|      0|#define EMP_LAYOUT_29(W, P, A, ...) W(A) P EMP_LAYOUT_28(W, P, __VA_ARGS__)
  641|      0|#define EMP_LAYOUT_30(W, P, A, ...) W(A) P EMP_LAYOUT_29(W, P, __VA_ARGS__)
  642|      0|#define EMP_LAYOUT_31(W, P, A, ...) W(A) P EMP_LAYOUT_30(W, P, __VA_ARGS__)
  643|      0|#define EMP_LAYOUT_32(W, P, A, ...) W(A) P EMP_LAYOUT_31(W, P, __VA_ARGS__)
  644|      0|#define EMP_LAYOUT_33(W, P, A, ...) W(A) P EMP_LAYOUT_32(W, P, __VA_ARGS__)
  645|      0|#define EMP_LAYOUT_34(W, P, A, ...) W(A) P EMP_LAYOUT_33(W, P, __VA_ARGS__)
  646|      0|#define EMP_LAYOUT_35(W, P, A, ...) W(A) P EMP_LAYOUT_34(W, P, __VA_ARGS__)
  647|      0|#define EMP_LAYOUT_36(W, P, A, ...) W(A) P EMP_LAYOUT_35(W, P, __VA_ARGS__)
  648|      0|#define EMP_LAYOUT_37(W, P, A, ...) W(A) P EMP_LAYOUT_36(W, P, __VA_ARGS__)
  649|      0|#define EMP_LAYOUT_38(W, P, A, ...) W(A) P EMP_LAYOUT_37(W, P, __VA_ARGS__)
  650|      0|#define EMP_LAYOUT_39(W, P, A, ...) W(A) P EMP_LAYOUT_38(W, P, __VA_ARGS__)
  651|      0|#define EMP_LAYOUT_40(W, P, A, ...) W(A) P EMP_LAYOUT_39(W, P, __VA_ARGS__)
  652|      0|#define EMP_LAYOUT_41(W, P, A, ...) W(A) P EMP_LAYOUT_40(W, P, __VA_ARGS__)
  653|      0|#define EMP_LAYOUT_42(W, P, A, ...) W(A) P EMP_LAYOUT_41(W, P, __VA_ARGS__)
  654|      0|#define EMP_LAYOUT_43(W, P, A, ...) W(A) P EMP_LAYOUT_42(W, P, __VA_ARGS__)
  655|      0|#define EMP_LAYOUT_44(W, P, A, ...) W(A) P EMP_LAYOUT_43(W, P, __VA_ARGS__)
  656|      0|#define EMP_LAYOUT_45(W, P, A, ...) W(A) P EMP_LAYOUT_44(W, P, __VA_ARGS__)
  657|      0|#define EMP_LAYOUT_46(W, P, A, ...) W(A) P EMP_LAYOUT_45(W, P, __VA_ARGS__)
  658|      0|#define EMP_LAYOUT_47(W, P, A, ...) W(A) P EMP_LAYOUT_46(W, P, __VA_ARGS__)
  659|      0|#define EMP_LAYOUT_48(W, P, A, ...) W(A) P EMP_LAYOUT_47(W, P, __VA_ARGS__)
  660|      0|#define EMP_LAYOUT_49(W, P, A, ...) W(A) P EMP_LAYOUT_48(W, P, __VA_ARGS__)
  661|      0|#define EMP_LAYOUT_50(W, P, A, ...) W(A) P EMP_LAYOUT_49(W, P, __VA_ARGS__)
  662|      0|#define EMP_LAYOUT_51(W, P, A, ...) W(A) P EMP_LAYOUT_50(W, P, __VA_ARGS__)
  663|      0|#define EMP_LAYOUT_52(W, P, A, ...) W(A) P EMP_LAYOUT_51(W, P, __VA_ARGS__)
  664|      0|#define EMP_LAYOUT_53(W, P, A, ...) W(A) P EMP_LAYOUT_52(W, P, __VA_ARGS__)
  665|      0|#define EMP_LAYOUT_54(W, P, A, ...) W(A) P EMP_LAYOUT_53(W, P, __VA_ARGS__)
  666|      0|#define EMP_LAYOUT_55(W, P, A, ...) W(A) P EMP_LAYOUT_54(W, P, __VA_ARGS__)
  667|      0|#define EMP_LAYOUT_56(W, P, A, ...) W(A) P EMP_LAYOUT_55(W, P, __VA_ARGS__)
  668|      0|#define EMP_LAYOUT_57(W, P, A, ...) W(A) P EMP_LAYOUT_56(W, P, __VA_ARGS__)
  669|      0|#define EMP_LAYOUT_58(W, P, A, ...) W(A) P EMP_LAYOUT_57(W, P, __VA_ARGS__)
  670|      0|#define EMP_LAYOUT_59(W, P, A, ...) W(A) P EMP_LAYOUT_58(W, P, __VA_ARGS__)
  671|      0|#define EMP_LAYOUT_60(W, P, A, ...) W(A) P EMP_LAYOUT_59(W, P, __VA_ARGS__)
  672|      0|#define EMP_LAYOUT_61(W, P, A, ...) W(A) P EMP_LAYOUT_60(W, P, __VA_ARGS__)
  673|      0|#define EMP_LAYOUT_62(W, P, A, ...) W(A) P EMP_LAYOUT_61(W, P, __VA_ARGS__)
  674|      0|#define EMP_LAYOUT_63(W, P, A, ...) W(A) P EMP_LAYOUT_62(W, P, __VA_ARGS__)
  675|       |/// @endcond
  676|       |
  677|       |// Wrap C different arguments.
  678|      0|#define EMP_WRAP_ARGSET(W, C, ...) EMP_ASSEMBLE_MACRO_2ARG(EMP_WRAP_ARGS_, W, C, __VA_ARGS__)
  679|       |/// @cond MACROS
  680|       |#define EMP_WRAP_ARGSET_0(W, C, ...)
  681|      0|#define EMP_WRAP_ARGSET_1(W, C, ...) W( EMP_CROP_ARGS_TO(C, __VA_ARGS__) ), \
  682|      0|                                                                                                     EMP_MERGE_2( EMP_WRAP_ARGSET_, EMP_SUB_1_ ## C ) (W, C, EMP_CROP_OFF(C, __VA_ARGS__) )
  683|      0|#define EMP_WRAP_ARGSET_2(W, C, ...) W(A), EMP_WRAP_ARGSET_1(W, C, __VA_ARGS__)
  684|      0|#define EMP_WRAP_ARGSET_3(W, C, ...) W(A), EMP_WRAP_ARGSET_2(W, C, __VA_ARGS__)
  685|       |/// @endcond
  686|       |
  687|       |/// Individually stringifies each variable passed to it and returns them
  688|       |/// with commas in between.
  689|      2|#define EMP_STRINGIFY_EACH(...) EMP_WRAP_ARGS(EMP_STRINGIFY, __VA_ARGS__)
  690|       |
  691|       |/// Similar to EMP_WRAP_ARGS, but passes pairs of args into W.
  692|      0|#define EMP_WRAP_ARG_PAIRS(W, ...) EMP_ASSEMBLE_MACRO_1ARG(EMP_WRAP_ARG_PAIRS_, W, __VA_ARGS__)
  693|       |/// @cond MACROS
  694|      0|#define EMP_WRAP_ARG_PAIRS_2(W, A1, A2) W(A1, A2)
  695|      0|#define EMP_WRAP_ARG_PAIRS_4(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_2(W, __VA_ARGS__)
  696|      0|#define EMP_WRAP_ARG_PAIRS_6(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_4(W, __VA_ARGS__)
  697|      0|#define EMP_WRAP_ARG_PAIRS_8(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_6(W, __VA_ARGS__)
  698|      0|#define EMP_WRAP_ARG_PAIRS_10(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_8(W, __VA_ARGS__)
  699|      0|#define EMP_WRAP_ARG_PAIRS_12(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_10(W, __VA_ARGS__)
  700|      0|#define EMP_WRAP_ARG_PAIRS_14(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_12(W, __VA_ARGS__)
  701|      0|#define EMP_WRAP_ARG_PAIRS_16(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_14(W, __VA_ARGS__)
  702|      0|#define EMP_WRAP_ARG_PAIRS_18(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_16(W, __VA_ARGS__)
  703|      0|#define EMP_WRAP_ARG_PAIRS_20(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_18(W, __VA_ARGS__)
  704|      0|#define EMP_WRAP_ARG_PAIRS_22(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_20(W, __VA_ARGS__)
  705|      0|#define EMP_WRAP_ARG_PAIRS_24(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_22(W, __VA_ARGS__)
  706|      0|#define EMP_WRAP_ARG_PAIRS_26(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_24(W, __VA_ARGS__)
  707|      0|#define EMP_WRAP_ARG_PAIRS_28(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_26(W, __VA_ARGS__)
  708|      0|#define EMP_WRAP_ARG_PAIRS_30(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_28(W, __VA_ARGS__)
  709|      0|#define EMP_WRAP_ARG_PAIRS_32(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_30(W, __VA_ARGS__)
  710|      0|#define EMP_WRAP_ARG_PAIRS_34(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_32(W, __VA_ARGS__)
  711|      0|#define EMP_WRAP_ARG_PAIRS_36(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_34(W, __VA_ARGS__)
  712|      0|#define EMP_WRAP_ARG_PAIRS_38(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_36(W, __VA_ARGS__)
  713|      0|#define EMP_WRAP_ARG_PAIRS_40(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_38(W, __VA_ARGS__)
  714|      0|#define EMP_WRAP_ARG_PAIRS_42(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_40(W, __VA_ARGS__)
  715|      0|#define EMP_WRAP_ARG_PAIRS_44(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_42(W, __VA_ARGS__)
  716|      0|#define EMP_WRAP_ARG_PAIRS_46(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_44(W, __VA_ARGS__)
  717|      0|#define EMP_WRAP_ARG_PAIRS_48(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_46(W, __VA_ARGS__)
  718|      0|#define EMP_WRAP_ARG_PAIRS_50(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_48(W, __VA_ARGS__)
  719|      0|#define EMP_WRAP_ARG_PAIRS_52(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_50(W, __VA_ARGS__)
  720|      0|#define EMP_WRAP_ARG_PAIRS_54(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_52(W, __VA_ARGS__)
  721|      0|#define EMP_WRAP_ARG_PAIRS_56(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_54(W, __VA_ARGS__)
  722|      0|#define EMP_WRAP_ARG_PAIRS_58(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_56(W, __VA_ARGS__)
  723|      0|#define EMP_WRAP_ARG_PAIRS_60(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_58(W, __VA_ARGS__)
  724|      0|#define EMP_WRAP_ARG_PAIRS_62(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_60(W, __VA_ARGS__)
  725|      0|#define EMP_WRAP_ARG_PAIRS_64(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_62(W, __VA_ARGS__)
  726|      0|#define EMP_WRAP_ARG_PAIRS_66(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_64(W, __VA_ARGS__)
  727|      0|#define EMP_WRAP_ARG_PAIRS_68(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_66(W, __VA_ARGS__)
  728|      0|#define EMP_WRAP_ARG_PAIRS_70(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_68(W, __VA_ARGS__)
  729|      0|#define EMP_WRAP_ARG_PAIRS_72(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_70(W, __VA_ARGS__)
  730|      0|#define EMP_WRAP_ARG_PAIRS_74(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_72(W, __VA_ARGS__)
  731|      0|#define EMP_WRAP_ARG_PAIRS_76(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_74(W, __VA_ARGS__)
  732|      0|#define EMP_WRAP_ARG_PAIRS_78(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_76(W, __VA_ARGS__)
  733|      0|#define EMP_WRAP_ARG_PAIRS_80(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_78(W, __VA_ARGS__)
  734|      0|#define EMP_WRAP_ARG_PAIRS_82(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_80(W, __VA_ARGS__)
  735|      0|#define EMP_WRAP_ARG_PAIRS_84(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_82(W, __VA_ARGS__)
  736|      0|#define EMP_WRAP_ARG_PAIRS_86(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_84(W, __VA_ARGS__)
  737|      0|#define EMP_WRAP_ARG_PAIRS_88(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_86(W, __VA_ARGS__)
  738|      0|#define EMP_WRAP_ARG_PAIRS_90(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_88(W, __VA_ARGS__)
  739|      0|#define EMP_WRAP_ARG_PAIRS_92(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_90(W, __VA_ARGS__)
  740|      0|#define EMP_WRAP_ARG_PAIRS_94(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_92(W, __VA_ARGS__)
  741|      0|#define EMP_WRAP_ARG_PAIRS_96(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_94(W, __VA_ARGS__)
  742|      0|#define EMP_WRAP_ARG_PAIRS_98(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_96(W, __VA_ARGS__)
  743|      0|#define EMP_WRAP_ARG_PAIRS_100(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_98(W, __VA_ARGS__)
  744|      0|#define EMP_WRAP_ARG_PAIRS_102(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_100(W, __VA_ARGS__)
  745|      0|#define EMP_WRAP_ARG_PAIRS_104(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_102(W, __VA_ARGS__)
  746|      0|#define EMP_WRAP_ARG_PAIRS_106(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_104(W, __VA_ARGS__)
  747|      0|#define EMP_WRAP_ARG_PAIRS_108(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_106(W, __VA_ARGS__)
  748|      0|#define EMP_WRAP_ARG_PAIRS_110(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_108(W, __VA_ARGS__)
  749|      0|#define EMP_WRAP_ARG_PAIRS_112(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_110(W, __VA_ARGS__)
  750|      0|#define EMP_WRAP_ARG_PAIRS_114(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_112(W, __VA_ARGS__)
  751|      0|#define EMP_WRAP_ARG_PAIRS_116(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_114(W, __VA_ARGS__)
  752|      0|#define EMP_WRAP_ARG_PAIRS_118(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_116(W, __VA_ARGS__)
  753|      0|#define EMP_WRAP_ARG_PAIRS_120(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_118(W, __VA_ARGS__)
  754|      0|#define EMP_WRAP_ARG_PAIRS_122(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_120(W, __VA_ARGS__)
  755|      0|#define EMP_WRAP_ARG_PAIRS_124(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_122(W, __VA_ARGS__)
  756|      0|#define EMP_WRAP_ARG_PAIRS_126(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_124(W, __VA_ARGS__)
  757|      0|#define EMP_WRAP_ARG_PAIRS_128(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_126(W, __VA_ARGS__)
  758|       |/// @endcond
  759|       |
  760|      0|#define EMP_WRAP_ARG_TRIPLES(W, ...) EMP_ASSEMBLE_MACRO_1ARG(EMP_WRAP_ARG_TRIPLES_, W, __VA_ARGS__)
  761|       |/// @cond MACROS
  762|      0|#define EMP_WRAP_ARG_TRIPLES_3(W, A,B,C) W(A, B, C)
  763|      0|#define EMP_WRAP_ARG_TRIPLES_6(W, A,B,C, ...) W(A,B,C), EMP_WRAP_ARG_TRIPLES_3(W, __VA_ARGS__)
  764|      0|#define EMP_WRAP_ARG_TRIPLES_9(W, A,B,C, ...) W(A,B,C), EMP_WRAP_ARG_TRIPLES_6(W, __VA_ARGS__)
  765|      0|#define EMP_WRAP_ARG_TRIPLES_12(W, A,B,C, ...) W(A,B,C), EMP_WRAP_ARG_TRIPLES_9(W, __VA_ARGS__)
  766|       |/// @endcond
  767|       |
  768|       |/// Reverse the order of arguments passed in.
  769|      0|#define EMP_REVERSE_ARGS(...) EMP_ASSEMBLE_MACRO(EMP_REVERSE_ARGS_, __VA_ARGS__)
  770|       |/// @cond MACROS
  771|      0|#define EMP_REVERSE_ARGS_1(A) A
  772|      0|#define EMP_REVERSE_ARGS_2(A, ...) EMP_REVERSE_ARGS_1(__VA_ARGS__), A
  773|      0|#define EMP_REVERSE_ARGS_3(A, ...) EMP_REVERSE_ARGS_2(__VA_ARGS__), A
  774|      0|#define EMP_REVERSE_ARGS_4(A, ...) EMP_REVERSE_ARGS_3(__VA_ARGS__), A
  775|      0|#define EMP_REVERSE_ARGS_5(A, ...) EMP_REVERSE_ARGS_4(__VA_ARGS__), A
  776|      0|#define EMP_REVERSE_ARGS_6(A, ...) EMP_REVERSE_ARGS_5(__VA_ARGS__), A
  777|      0|#define EMP_REVERSE_ARGS_7(A, ...) EMP_REVERSE_ARGS_6(__VA_ARGS__), A
  778|      0|#define EMP_REVERSE_ARGS_8(A, ...) EMP_REVERSE_ARGS_7(__VA_ARGS__), A
  779|      0|#define EMP_REVERSE_ARGS_9(A, ...) EMP_REVERSE_ARGS_8(__VA_ARGS__), A
  780|      0|#define EMP_REVERSE_ARGS_10(A, ...) EMP_REVERSE_ARGS_9(__VA_ARGS__), A
  781|      0|#define EMP_REVERSE_ARGS_11(A, ...) EMP_REVERSE_ARGS_10(__VA_ARGS__), A
  782|      0|#define EMP_REVERSE_ARGS_12(A, ...) EMP_REVERSE_ARGS_11(__VA_ARGS__), A
  783|      0|#define EMP_REVERSE_ARGS_13(A, ...) EMP_REVERSE_ARGS_12(__VA_ARGS__), A
  784|      0|#define EMP_REVERSE_ARGS_14(A, ...) EMP_REVERSE_ARGS_13(__VA_ARGS__), A
  785|      0|#define EMP_REVERSE_ARGS_15(A, ...) EMP_REVERSE_ARGS_14(__VA_ARGS__), A
  786|      0|#define EMP_REVERSE_ARGS_16(A, ...) EMP_REVERSE_ARGS_15(__VA_ARGS__), A
  787|      0|#define EMP_REVERSE_ARGS_17(A, ...) EMP_REVERSE_ARGS_16(__VA_ARGS__), A
  788|      0|#define EMP_REVERSE_ARGS_18(A, ...) EMP_REVERSE_ARGS_17(__VA_ARGS__), A
  789|      0|#define EMP_REVERSE_ARGS_19(A, ...) EMP_REVERSE_ARGS_18(__VA_ARGS__), A
  790|      0|#define EMP_REVERSE_ARGS_20(A, ...) EMP_REVERSE_ARGS_19(__VA_ARGS__), A
  791|      0|#define EMP_REVERSE_ARGS_21(A, ...) EMP_REVERSE_ARGS_20(__VA_ARGS__), A
  792|      0|#define EMP_REVERSE_ARGS_22(A, ...) EMP_REVERSE_ARGS_21(__VA_ARGS__), A
  793|      0|#define EMP_REVERSE_ARGS_23(A, ...) EMP_REVERSE_ARGS_22(__VA_ARGS__), A
  794|      0|#define EMP_REVERSE_ARGS_24(A, ...) EMP_REVERSE_ARGS_23(__VA_ARGS__), A
  795|      0|#define EMP_REVERSE_ARGS_25(A, ...) EMP_REVERSE_ARGS_24(__VA_ARGS__), A
  796|      0|#define EMP_REVERSE_ARGS_26(A, ...) EMP_REVERSE_ARGS_25(__VA_ARGS__), A
  797|      0|#define EMP_REVERSE_ARGS_27(A, ...) EMP_REVERSE_ARGS_26(__VA_ARGS__), A
  798|      0|#define EMP_REVERSE_ARGS_28(A, ...) EMP_REVERSE_ARGS_27(__VA_ARGS__), A
  799|      0|#define EMP_REVERSE_ARGS_29(A, ...) EMP_REVERSE_ARGS_28(__VA_ARGS__), A
  800|      0|#define EMP_REVERSE_ARGS_30(A, ...) EMP_REVERSE_ARGS_29(__VA_ARGS__), A
  801|      0|#define EMP_REVERSE_ARGS_31(A, ...) EMP_REVERSE_ARGS_30(__VA_ARGS__), A
  802|      0|#define EMP_REVERSE_ARGS_32(A, ...) EMP_REVERSE_ARGS_31(__VA_ARGS__), A
  803|      0|#define EMP_REVERSE_ARGS_33(A, ...) EMP_REVERSE_ARGS_32(__VA_ARGS__), A
  804|      0|#define EMP_REVERSE_ARGS_34(A, ...) EMP_REVERSE_ARGS_33(__VA_ARGS__), A
  805|      0|#define EMP_REVERSE_ARGS_35(A, ...) EMP_REVERSE_ARGS_34(__VA_ARGS__), A
  806|      0|#define EMP_REVERSE_ARGS_36(A, ...) EMP_REVERSE_ARGS_35(__VA_ARGS__), A
  807|      0|#define EMP_REVERSE_ARGS_37(A, ...) EMP_REVERSE_ARGS_36(__VA_ARGS__), A
  808|      0|#define EMP_REVERSE_ARGS_38(A, ...) EMP_REVERSE_ARGS_37(__VA_ARGS__), A
  809|      0|#define EMP_REVERSE_ARGS_39(A, ...) EMP_REVERSE_ARGS_38(__VA_ARGS__), A
  810|      0|#define EMP_REVERSE_ARGS_40(A, ...) EMP_REVERSE_ARGS_39(__VA_ARGS__), A
  811|      0|#define EMP_REVERSE_ARGS_41(A, ...) EMP_REVERSE_ARGS_40(__VA_ARGS__), A
  812|      0|#define EMP_REVERSE_ARGS_42(A, ...) EMP_REVERSE_ARGS_41(__VA_ARGS__), A
  813|      0|#define EMP_REVERSE_ARGS_43(A, ...) EMP_REVERSE_ARGS_42(__VA_ARGS__), A
  814|      0|#define EMP_REVERSE_ARGS_44(A, ...) EMP_REVERSE_ARGS_43(__VA_ARGS__), A
  815|      0|#define EMP_REVERSE_ARGS_45(A, ...) EMP_REVERSE_ARGS_44(__VA_ARGS__), A
  816|      0|#define EMP_REVERSE_ARGS_46(A, ...) EMP_REVERSE_ARGS_45(__VA_ARGS__), A
  817|      0|#define EMP_REVERSE_ARGS_47(A, ...) EMP_REVERSE_ARGS_46(__VA_ARGS__), A
  818|      0|#define EMP_REVERSE_ARGS_48(A, ...) EMP_REVERSE_ARGS_47(__VA_ARGS__), A
  819|      0|#define EMP_REVERSE_ARGS_49(A, ...) EMP_REVERSE_ARGS_48(__VA_ARGS__), A
  820|      0|#define EMP_REVERSE_ARGS_50(A, ...) EMP_REVERSE_ARGS_49(__VA_ARGS__), A
  821|      0|#define EMP_REVERSE_ARGS_51(A, ...) EMP_REVERSE_ARGS_50(__VA_ARGS__), A
  822|      0|#define EMP_REVERSE_ARGS_52(A, ...) EMP_REVERSE_ARGS_51(__VA_ARGS__), A
  823|      0|#define EMP_REVERSE_ARGS_53(A, ...) EMP_REVERSE_ARGS_52(__VA_ARGS__), A
  824|      0|#define EMP_REVERSE_ARGS_54(A, ...) EMP_REVERSE_ARGS_53(__VA_ARGS__), A
  825|      0|#define EMP_REVERSE_ARGS_55(A, ...) EMP_REVERSE_ARGS_54(__VA_ARGS__), A
  826|      0|#define EMP_REVERSE_ARGS_56(A, ...) EMP_REVERSE_ARGS_55(__VA_ARGS__), A
  827|      0|#define EMP_REVERSE_ARGS_57(A, ...) EMP_REVERSE_ARGS_56(__VA_ARGS__), A
  828|      0|#define EMP_REVERSE_ARGS_58(A, ...) EMP_REVERSE_ARGS_57(__VA_ARGS__), A
  829|      0|#define EMP_REVERSE_ARGS_59(A, ...) EMP_REVERSE_ARGS_58(__VA_ARGS__), A
  830|      0|#define EMP_REVERSE_ARGS_60(A, ...) EMP_REVERSE_ARGS_59(__VA_ARGS__), A
  831|      0|#define EMP_REVERSE_ARGS_61(A, ...) EMP_REVERSE_ARGS_60(__VA_ARGS__), A
  832|      0|#define EMP_REVERSE_ARGS_62(A, ...) EMP_REVERSE_ARGS_61(__VA_ARGS__), A
  833|      0|#define EMP_REVERSE_ARGS_63(A, ...) EMP_REVERSE_ARGS_62(__VA_ARGS__), A
  834|      0|#define EMP_REVERSE_ARGS_64(A, ...) EMP_REVERSE_ARGS_63(__VA_ARGS__), A
  835|       |/// @endcond
  836|       |
  837|      0|#define EMP_TYPES_TO_ARGS(...) EMP_ASSEMBLE_MACRO(EMP_TYPES_TO_ARGS_, EMP_REVERSE_ARGS(__VA_ARGS__))
  838|       |/// @cond MACROS
  839|      0|#define EMP_TYPES_TO_ARGS_1(A) A arg1
  840|      0|#define EMP_TYPES_TO_ARGS_2(A, ...) EMP_TYPES_TO_ARGS_1(__VA_ARGS__), A arg2
  841|      0|#define EMP_TYPES_TO_ARGS_3(A, ...) EMP_TYPES_TO_ARGS_2(__VA_ARGS__), A arg3
  842|      0|#define EMP_TYPES_TO_ARGS_4(A, ...) EMP_TYPES_TO_ARGS_3(__VA_ARGS__), A arg4
  843|      0|#define EMP_TYPES_TO_ARGS_5(A, ...) EMP_TYPES_TO_ARGS_4(__VA_ARGS__), A arg5
  844|      0|#define EMP_TYPES_TO_ARGS_6(A, ...) EMP_TYPES_TO_ARGS_5(__VA_ARGS__), A arg6
  845|      0|#define EMP_TYPES_TO_ARGS_7(A, ...) EMP_TYPES_TO_ARGS_6(__VA_ARGS__), A arg7
  846|      0|#define EMP_TYPES_TO_ARGS_8(A, ...) EMP_TYPES_TO_ARGS_7(__VA_ARGS__), A arg8
  847|      0|#define EMP_TYPES_TO_ARGS_9(A, ...) EMP_TYPES_TO_ARGS_8(__VA_ARGS__), A arg9
  848|      0|#define EMP_TYPES_TO_ARGS_10(A, ...) EMP_TYPES_TO_ARGS_9(__VA_ARGS__), A arg10
  849|      0|#define EMP_TYPES_TO_ARGS_11(A, ...) EMP_TYPES_TO_ARGS_10(__VA_ARGS__), A arg11
  850|      0|#define EMP_TYPES_TO_ARGS_12(A, ...) EMP_TYPES_TO_ARGS_11(__VA_ARGS__), A arg12
  851|      0|#define EMP_TYPES_TO_ARGS_13(A, ...) EMP_TYPES_TO_ARGS_12(__VA_ARGS__), A arg13
  852|      0|#define EMP_TYPES_TO_ARGS_14(A, ...) EMP_TYPES_TO_ARGS_13(__VA_ARGS__), A arg14
  853|      0|#define EMP_TYPES_TO_ARGS_15(A, ...) EMP_TYPES_TO_ARGS_14(__VA_ARGS__), A arg15
  854|      0|#define EMP_TYPES_TO_ARGS_16(A, ...) EMP_TYPES_TO_ARGS_15(__VA_ARGS__), A arg16
  855|      0|#define EMP_TYPES_TO_ARGS_17(A, ...) EMP_TYPES_TO_ARGS_16(__VA_ARGS__), A arg17
  856|      0|#define EMP_TYPES_TO_ARGS_18(A, ...) EMP_TYPES_TO_ARGS_17(__VA_ARGS__), A arg18
  857|      0|#define EMP_TYPES_TO_ARGS_19(A, ...) EMP_TYPES_TO_ARGS_18(__VA_ARGS__), A arg19
  858|      0|#define EMP_TYPES_TO_ARGS_20(A, ...) EMP_TYPES_TO_ARGS_19(__VA_ARGS__), A arg20
  859|      0|#define EMP_TYPES_TO_ARGS_21(A, ...) EMP_TYPES_TO_ARGS_20(__VA_ARGS__), A arg21
  860|      0|#define EMP_TYPES_TO_ARGS_22(A, ...) EMP_TYPES_TO_ARGS_21(__VA_ARGS__), A arg22
  861|      0|#define EMP_TYPES_TO_ARGS_23(A, ...) EMP_TYPES_TO_ARGS_22(__VA_ARGS__), A arg23
  862|      0|#define EMP_TYPES_TO_ARGS_24(A, ...) EMP_TYPES_TO_ARGS_23(__VA_ARGS__), A arg24
  863|      0|#define EMP_TYPES_TO_ARGS_25(A, ...) EMP_TYPES_TO_ARGS_24(__VA_ARGS__), A arg25
  864|      0|#define EMP_TYPES_TO_ARGS_26(A, ...) EMP_TYPES_TO_ARGS_25(__VA_ARGS__), A arg26
  865|      0|#define EMP_TYPES_TO_ARGS_27(A, ...) EMP_TYPES_TO_ARGS_26(__VA_ARGS__), A arg27
  866|      0|#define EMP_TYPES_TO_ARGS_28(A, ...) EMP_TYPES_TO_ARGS_27(__VA_ARGS__), A arg28
  867|      0|#define EMP_TYPES_TO_ARGS_29(A, ...) EMP_TYPES_TO_ARGS_28(__VA_ARGS__), A arg29
  868|      0|#define EMP_TYPES_TO_ARGS_30(A, ...) EMP_TYPES_TO_ARGS_29(__VA_ARGS__), A arg30
  869|      0|#define EMP_TYPES_TO_ARGS_31(A, ...) EMP_TYPES_TO_ARGS_30(__VA_ARGS__), A arg31
  870|      0|#define EMP_TYPES_TO_ARGS_32(A, ...) EMP_TYPES_TO_ARGS_31(__VA_ARGS__), A arg32
  871|      0|#define EMP_TYPES_TO_ARGS_33(A, ...) EMP_TYPES_TO_ARGS_32(__VA_ARGS__), A arg33
  872|      0|#define EMP_TYPES_TO_ARGS_34(A, ...) EMP_TYPES_TO_ARGS_33(__VA_ARGS__), A arg34
  873|      0|#define EMP_TYPES_TO_ARGS_35(A, ...) EMP_TYPES_TO_ARGS_34(__VA_ARGS__), A arg35
  874|      0|#define EMP_TYPES_TO_ARGS_36(A, ...) EMP_TYPES_TO_ARGS_35(__VA_ARGS__), A arg36
  875|      0|#define EMP_TYPES_TO_ARGS_37(A, ...) EMP_TYPES_TO_ARGS_36(__VA_ARGS__), A arg37
  876|      0|#define EMP_TYPES_TO_ARGS_38(A, ...) EMP_TYPES_TO_ARGS_37(__VA_ARGS__), A arg38
  877|      0|#define EMP_TYPES_TO_ARGS_39(A, ...) EMP_TYPES_TO_ARGS_38(__VA_ARGS__), A arg39
  878|      0|#define EMP_TYPES_TO_ARGS_40(A, ...) EMP_TYPES_TO_ARGS_39(__VA_ARGS__), A arg40
  879|      0|#define EMP_TYPES_TO_ARGS_41(A, ...) EMP_TYPES_TO_ARGS_40(__VA_ARGS__), A arg41
  880|      0|#define EMP_TYPES_TO_ARGS_42(A, ...) EMP_TYPES_TO_ARGS_41(__VA_ARGS__), A arg42
  881|      0|#define EMP_TYPES_TO_ARGS_43(A, ...) EMP_TYPES_TO_ARGS_42(__VA_ARGS__), A arg43
  882|      0|#define EMP_TYPES_TO_ARGS_44(A, ...) EMP_TYPES_TO_ARGS_43(__VA_ARGS__), A arg44
  883|      0|#define EMP_TYPES_TO_ARGS_45(A, ...) EMP_TYPES_TO_ARGS_44(__VA_ARGS__), A arg45
  884|      0|#define EMP_TYPES_TO_ARGS_46(A, ...) EMP_TYPES_TO_ARGS_45(__VA_ARGS__), A arg46
  885|      0|#define EMP_TYPES_TO_ARGS_47(A, ...) EMP_TYPES_TO_ARGS_46(__VA_ARGS__), A arg47
  886|      0|#define EMP_TYPES_TO_ARGS_48(A, ...) EMP_TYPES_TO_ARGS_47(__VA_ARGS__), A arg48
  887|      0|#define EMP_TYPES_TO_ARGS_49(A, ...) EMP_TYPES_TO_ARGS_48(__VA_ARGS__), A arg49
  888|      0|#define EMP_TYPES_TO_ARGS_50(A, ...) EMP_TYPES_TO_ARGS_49(__VA_ARGS__), A arg50
  889|      0|#define EMP_TYPES_TO_ARGS_51(A, ...) EMP_TYPES_TO_ARGS_50(__VA_ARGS__), A arg51
  890|      0|#define EMP_TYPES_TO_ARGS_52(A, ...) EMP_TYPES_TO_ARGS_51(__VA_ARGS__), A arg52
  891|      0|#define EMP_TYPES_TO_ARGS_53(A, ...) EMP_TYPES_TO_ARGS_52(__VA_ARGS__), A arg53
  892|      0|#define EMP_TYPES_TO_ARGS_54(A, ...) EMP_TYPES_TO_ARGS_53(__VA_ARGS__), A arg54
  893|      0|#define EMP_TYPES_TO_ARGS_55(A, ...) EMP_TYPES_TO_ARGS_54(__VA_ARGS__), A arg55
  894|      0|#define EMP_TYPES_TO_ARGS_56(A, ...) EMP_TYPES_TO_ARGS_55(__VA_ARGS__), A arg56
  895|      0|#define EMP_TYPES_TO_ARGS_57(A, ...) EMP_TYPES_TO_ARGS_56(__VA_ARGS__), A arg57
  896|      0|#define EMP_TYPES_TO_ARGS_58(A, ...) EMP_TYPES_TO_ARGS_57(__VA_ARGS__), A arg58
  897|      0|#define EMP_TYPES_TO_ARGS_59(A, ...) EMP_TYPES_TO_ARGS_58(__VA_ARGS__), A arg59
  898|      0|#define EMP_TYPES_TO_ARGS_60(A, ...) EMP_TYPES_TO_ARGS_59(__VA_ARGS__), A arg60
  899|      0|#define EMP_TYPES_TO_ARGS_61(A, ...) EMP_TYPES_TO_ARGS_60(__VA_ARGS__), A arg61
  900|      0|#define EMP_TYPES_TO_ARGS_62(A, ...) EMP_TYPES_TO_ARGS_61(__VA_ARGS__), A arg62
  901|      0|#define EMP_TYPES_TO_ARGS_63(A, ...) EMP_TYPES_TO_ARGS_62(__VA_ARGS__), A arg63
  902|       |/// @endcond
  903|       |
  904|       |/// EMP_ASSEMBLE_MACRO takes in a prefix and set of arguments and appends the size of the
  905|       |/// number of arguments to the prefix, and passes in all of the arguments.
  906|       |/// Setup a generic method of calling a specific version of a macro based on argument count.
  907|       |/// If some of the args need to be passed to each version, specify number in macro call.
  908|      0|#define EMP_ASSEMBLE_MACRO(BASE, ...)                                   \
  909|      0|  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), __VA_ARGS__)
  910|       |
  911|       |///  EMP_ASSEMBLE_MACRO_1ARG assumes the first argument after the prefix should not count
  912|       |///  toward the size, but passed in anyway. (*_?ARG  works for more arguments up to 10).
  913|      0|#define EMP_ASSEMBLE_MACRO_1ARG(BASE, A, ...)                           \
  914|      0|  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, __VA_ARGS__)
  915|       |
  916|       |/// @cond MACROS
  917|      0|#define EMP_ASSEMBLE_MACRO_2ARG(BASE, A, B, ...)                         \
  918|      0|  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, __VA_ARGS__)
  919|       |
  920|      0|#define EMP_ASSEMBLE_MACRO_3ARG(BASE, A, B, C, ...)                      \
  921|      0|  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, __VA_ARGS__)
  922|       |
  923|      0|#define EMP_ASSEMBLE_MACRO_4ARG(BASE, A, B, C, D, ...)                   \
  924|      0|  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, D, __VA_ARGS__)
  925|       |
  926|      0|#define EMP_ASSEMBLE_MACRO_5ARG(BASE, A, B, C, D, E, ...)                \
  927|      0|  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, D, E, __VA_ARGS__)
  928|       |
  929|      0|#define EMP_ASSEMBLE_MACRO_6ARG(BASE, A, B, C, D, E, F, ...)             \
  930|      0|  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, D, E, F, __VA_ARGS__)
  931|       |
  932|      0|#define EMP_ASSEMBLE_MACRO_7ARG(BASE, A, B, C, D, E, F, G, ...)          \
  933|      0|  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, D, E, F, G, __VA_ARGS__)
  934|       |
  935|      0|#define EMP_ASSEMBLE_MACRO_8ARG(BASE, A, B, C, D, E, F, G, H, ...)       \
  936|      0|  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, D, E, F, G, H, __VA_ARGS__)
  937|       |
  938|      0|#define EMP_ASSEMBLE_IMPL(BASE, ARG_COUNT, ...) EMP_ASSEMBLE_MERGE(BASE, ARG_COUNT) (__VA_ARGS__)
  939|      0|#define EMP_ASSEMBLE_MERGE(A, B) A ## B
  940|       |/// @endcond
  941|       |
  942|       |#endif
  943|       |

/home/emily/repos/Empirical_MoreTests/coverage_source/base/vector.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file vector.h
    7|       | *  @brief A drop-in wrapper for std::vector; adds on bounds checking in debug mode.
    8|       | *  @note Status: BETA
    9|       | *
   10|       | *  This class is a drop-in wrapper for std::vector, adding on bounds checking.
   11|       | *  If EMP_NDEBUG is set then it reverts back to std::vector.
   12|       | *
   13|       | *  @todo Debug code: member functions that take iterators should also take emp iterators that verify
   14|       | *        whether those iterators are valid.
   15|       | */
   16|       |
   17|       |
   18|       |#ifndef EMP_VECTOR_H
   19|       |#define EMP_VECTOR_H
   20|       |
   21|       |#include <initializer_list>
   22|       |#include <iterator>
   23|       |#include <utility>
   24|       |#include <vector>
   25|       |
   26|       |#include "assert.h"
   27|       |
   28|       |#ifdef EMP_NDEBUG
   29|       |
   30|       |// Seemlessly translate emp::vector to std::vector
   31|       |namespace emp {
   32|       |  template <typename... Ts> using vector = std::vector<Ts...>;
   33|       |}
   34|       |
   35|       |
   36|       |#else // #EMP_NDEBUG *not* set
   37|       |
   38|       |namespace emp {
   39|       |
   40|       |  /// Build a debug wrapper emp::vector around std::vector.
   41|       |  template <typename T, typename... Ts>
   42|       |  class vector : public std::vector<T,Ts...> {
   43|       |  private:
   44|       |    using this_t = emp::vector<T,Ts...>;
   45|       |    using stdv_t = std::vector<T,Ts...>;
   46|       |
   47|       |    /// Setup a threshold; if we try to make a vector bigger than MAX_SIZE, throw a warning.
   48|       |    constexpr static const size_t MAX_SIZE = 2000000001; // 2x10^9 + 1
   49|       |
   50|       |  public:
   51|       |    /// Setup a revision number - iterators must match the revision of their vector.
   52|       |    int revision;
   53|       |
   54|       |    /// Setup an iterator wrapper to make sure that they're not used again after a vector changes.
   55|       |    template<typename ITERATOR_T>
   56|       |    struct iterator_wrapper : public ITERATOR_T {
   57|       |      using this_t = iterator_wrapper<ITERATOR_T>;
   58|       |      using wrapped_t = ITERATOR_T;
   59|       |      using vec_t = emp::vector<T,Ts...>;
   60|       |
   61|       |      /// What vector and revision was this iterator created from?
   62|       |      const vec_t * v_ptr;
   63|       |      int revision;
   64|       |
   65|       |      // @CAO: For the moment cannot create an emp iterator from a base since we don't know vector to use.
   66|       |      // iterator_wrapper(const ITERATOR_T & _in)
   67|       |      //   : ITERATOR_T(_in), v_ptr(nullptr), revision(0) { ; }
   68|      0|      /*_FORCE_COVER_START_*/iterator_wrapper(const ITERATOR_T & _in, const vec_t * _v)
   69|     52|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_7PtrInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEEC2ERKSA_PKS2_:
  |   69|      2|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_7PtrInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS1_St6vectorIS1_SaIS1_EEEEEC2ERKSB_PKS2_:
  |   69|      8|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEEC2ERKS9_PKS1_:
  |   69|      2|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEEEC2ERKSA_PKS1_:
  |   69|     40|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
   70|      0|      /*_FORCE_COVER_START_*/iterator_wrapper(const this_t &) = default/*_FORCE_COVER_END_*/;
   71|      0|      /*_FORCE_COVER_START_*/iterator_wrapper(this_t &&) = default/*_FORCE_COVER_END_*/;
   72|    108|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_7PtrInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEED2Ev:
  |   72|      6|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_7PtrInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS1_St6vectorIS1_SaIS1_EEEEED2Ev:
  |   72|     16|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEED2Ev:
  |   72|      6|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEEED2Ev:
  |   72|     80|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
   73|       |
   74|       |      // Debug tools to make sure this iterator is okay.
   75|     48|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
   76|     48|        if (v_ptr == nullptr) return false;                // Invalid vector
   77|     48|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
   78|     48|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
   79|     48|        size_t pos = (size_t) (*this - v_ptr->begin());
   80|     48|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
   81|     48|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
   82|     48|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
   83|     48|        return true;
   84|     48|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_7PtrInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEE2OKEbb:
  |   75|      8|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|      8|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|      8|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|      8|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|      8|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|      8|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|      8|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|      8|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|      8|        return true;
  |   84|      8|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEE2OKEbb:
  |   75|     40|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|     40|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|     40|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|     40|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|     40|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|     40|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|     40|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|     40|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|     40|        return true;
  |   84|     40|      }/*_FORCE_COVER_END_*/
  ------------------
   85|       |
   86|      0|      /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
   87|      0|      /*_FORCE_COVER_START_*/this_t & operator=(this_t &&) = default/*_FORCE_COVER_END_*/;
   88|       |
   89|      0|      /*_FORCE_COVER_START_*/operator ITERATOR_T() { return *this; }/*_FORCE_COVER_END_*/
   90|      0|      /*_FORCE_COVER_START_*/operator const ITERATOR_T() const { return *this; }/*_FORCE_COVER_END_*/
   91|       |
   92|     24|      /*_FORCE_COVER_START_*/auto & operator*() {
   93|     24|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
   94|     24|        return wrapped_t::operator*();
   95|     24|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_7PtrInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEEdeEv:
  |   92|      4|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|      4|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|      4|        return wrapped_t::operator*();
  |   95|      4|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEEdeEv:
  |   92|     20|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|     20|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|     20|        return wrapped_t::operator*();
  |   95|     20|      }/*_FORCE_COVER_END_*/
  ------------------
   96|      0|      /*_FORCE_COVER_START_*/const auto & operator*() const {
   97|      0|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
   98|      0|        return wrapped_t::operator*();
   99|       |      }/*_FORCE_COVER_END_*/
  100|       |
  101|      0|      /*_FORCE_COVER_START_*/auto operator->() {
  102|      0|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  103|      0|        return wrapped_t::operator->();
  104|       |      }/*_FORCE_COVER_END_*/
  105|      0|      /*_FORCE_COVER_START_*/const auto operator->() const {
  106|      0|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  107|      0|        return wrapped_t::operator->();
  108|       |      }/*_FORCE_COVER_END_*/
  109|       |
  110|     24|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_7PtrInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEEppEv:
  |  110|      4|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEEppEv:
  |  110|     20|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  111|      0|      /*_FORCE_COVER_START_*/this_t operator++(int x) { emp_assert(OK(true,false)); return this_t(wrapped_t::operator++(x), v_ptr); }/*_FORCE_COVER_END_*/
  112|      0|      /*_FORCE_COVER_START_*/this_t & operator--() { emp_assert(OK(false,true)); wrapped_t::operator--(); return *this; }/*_FORCE_COVER_END_*/
  113|      0|      /*_FORCE_COVER_START_*/this_t operator--(int x) { emp_assert(OK(false,true)); return this_t(wrapped_t::operator--(x), v_ptr); }/*_FORCE_COVER_END_*/
  114|       |
  115|      0|      /*_FORCE_COVER_START_*/auto operator+(int in) { emp_assert(OK()); return this_t(wrapped_t::operator+(in), v_ptr); }/*_FORCE_COVER_END_*/
  116|      0|      /*_FORCE_COVER_START_*/auto operator-(int in) { emp_assert(OK()); return this_t(wrapped_t::operator-(in), v_ptr); }/*_FORCE_COVER_END_*/
  117|      0|      /*_FORCE_COVER_START_*/auto operator-(const this_t & in) { emp_assert(OK()); return ((wrapped_t) *this) - (wrapped_t) in; }/*_FORCE_COVER_END_*/
  118|       |
  119|      0|      /*_FORCE_COVER_START_*/this_t & operator+=(int in) { emp_assert(OK()); wrapped_t::operator+=(in); return *this; }/*_FORCE_COVER_END_*/
  120|      0|      /*_FORCE_COVER_START_*/this_t & operator-=(int in) { emp_assert(OK()); wrapped_t::operator-=(in); return *this; }/*_FORCE_COVER_END_*/
  121|      0|      /*_FORCE_COVER_START_*/auto & operator[](int offset) { emp_assert(OK()); return wrapped_t::operator[](offset); }/*_FORCE_COVER_END_*/
  122|       |
  123|       |      //bool operator==(const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator==(in); }
  124|       |      //bool operator!=(const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator!=(in); }
  125|       |
  126|       |      //bool operator< (const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator< (in); }
  127|       |      //bool operator<=(const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator<=(in); }
  128|       |      //bool operator> (const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator> (in); }
  129|       |      //bool operator>=(const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator>=(in); }
  130|       |    };
  131|       |
  132|       |    using iterator = iterator_wrapper< typename stdv_t::iterator >;
  133|       |    using const_iterator = iterator_wrapper< typename stdv_t::const_iterator >;
  134|       |    using reverse_iterator = iterator_wrapper< typename stdv_t::reverse_iterator >;
  135|       |    using const_reverse_iterator = iterator_wrapper< typename stdv_t::const_reverse_iterator >;
  136|       |    using value_type = T;
  137|       |    using size_type = typename stdv_t::size_type;
  138|       |    using reference = typename stdv_t::reference;
  139|       |    using const_reference = typename stdv_t::const_reference;
  140|       |
  141|      1|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  142|      0|    /*_FORCE_COVER_START_*/vector(const this_t & _in) : stdv_t(_in), revision(1) {}/*_FORCE_COVER_END_*/;
  143|      2|    /*_FORCE_COVER_START_*/vector(size_t size) : stdv_t(size), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIPNS_3PtrIcEEJEEC2Em:
  |  143|      1|    /*_FORCE_COVER_START_*/vector(size_t size) : stdv_t(size), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEEC2Em:
  |  143|      1|    /*_FORCE_COVER_START_*/vector(size_t size) : stdv_t(size), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  144|      0|    /*_FORCE_COVER_START_*/vector(size_t size, const T & val) : stdv_t(size, val), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  145|      0|    /*_FORCE_COVER_START_*/vector(std::initializer_list<T> in_list) : stdv_t(in_list), revision(1) { ; }/*_FORCE_COVER_END_*/
  146|      0|    /*_FORCE_COVER_START_*/vector(const stdv_t & in) : stdv_t(in), revision(1) { ; }/*_FORCE_COVER_END_*/         // Emergency fallback conversion.
  147|      0|    /*_FORCE_COVER_START_*/template <typename InputIt>
  148|      0|    /*_FORCE_COVER_START_*/vector(InputIt first, InputIt last) : stdv_t(first, last), revision(1) { ; }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  149|      3|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorINS_7PtrInfoEJEED2Ev:
  |  149|      1|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorIPNS_3PtrIcEEJEED2Ev:
  |  149|      1|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorIiJEED2Ev:
  |  149|      1|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  150|       |
  151|    104|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_7PtrInfoEJEE4sizeEv:
  |  151|     24|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIiJEE4sizeEv:
  |  151|     80|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  152|       |
  153|      2|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_7PtrInfoEJEE5beginEv:
  |  153|      1|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE5beginEv:
  |  153|      1|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  154|     48|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_7PtrInfoEJEE5beginEv:
  |  154|      8|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIiJEE5beginEv:
  |  154|     40|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  155|      2|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_7PtrInfoEJEE3endEv:
  |  155|      1|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE3endEv:
  |  155|      1|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  156|      0|    /*_FORCE_COVER_START_*/const_iterator end() const noexcept { return const_iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  157|       |
  158|       |    // operator stdv_t &() { return v; }
  159|       |    // operator const stdv_t &() const { return v; }
  160|       |
  161|      0|    /*_FORCE_COVER_START_*/void resize(size_t new_size) {
  162|      0|      emp_assert(new_size < MAX_SIZE, new_size);
  163|      0|      stdv_t::resize(new_size);
  164|      0|      revision++;
  165|       |    }/*_FORCE_COVER_END_*/
  166|      0|    /*_FORCE_COVER_START_*/void resize(size_t new_size, const T & val) {
  167|      0|      emp_assert(new_size < MAX_SIZE, new_size);
  168|      0|      stdv_t::resize(new_size, val);
  169|      0|      revision++;
  170|       |    }/*_FORCE_COVER_END_*/
  171|      0|    /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
  172|       |
  173|     75|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  174|     75|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  175|     75|      return stdv_t::operator[](pos);
  176|     75|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_7PtrInfoEJEEixEm:
  |  173|     26|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|     26|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|     26|      return stdv_t::operator[](pos);
  |  176|     26|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIPNS_3PtrIcEEJEEixEm:
  |  173|     29|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|     29|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|     29|      return stdv_t::operator[](pos);
  |  176|     29|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEEixEm:
  |  173|     20|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|     20|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|     20|      return stdv_t::operator[](pos);
  |  176|     20|    }/*_FORCE_COVER_END_*/
  ------------------
  177|       |
  178|      9|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  179|      9|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  180|      9|      return stdv_t::operator[](pos);
  181|      9|    }/*_FORCE_COVER_END_*/
  182|       |
  183|      0|    /*_FORCE_COVER_START_*/T & back() { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }/*_FORCE_COVER_END_*/
  184|      0|    /*_FORCE_COVER_START_*/const T & back() const { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }/*_FORCE_COVER_END_*/
  185|      0|    /*_FORCE_COVER_START_*/T & front() { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }/*_FORCE_COVER_END_*/
  186|      0|    /*_FORCE_COVER_START_*/const T & front() const { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }/*_FORCE_COVER_END_*/
  187|       |
  188|      0|    /*_FORCE_COVER_START_*/template <typename... PB_Ts>
  189|      0|    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) {
  190|      0|      stdv_t::push_back(std::forward<PB_Ts>(args)...);
  191|      0|      revision++;
  192|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  193|       |
  194|      0|    /*_FORCE_COVER_START_*/void pop_back() {
  195|      0|      emp_assert(stdv_t::size() > 0, stdv_t::size());
  196|      0|      stdv_t::pop_back();
  197|      0|      revision++;           // Technically reducing size can cause memory reallocation, but less likely.
  198|       |    }/*_FORCE_COVER_END_*/
  199|       |
  200|      0|    /*_FORCE_COVER_START_*/template <typename... ARGS>
  201|      0|    /*_FORCE_COVER_START_*/iterator insert(ARGS &&... args) {
  202|      0|      ++revision;
  203|      0|      return iterator( stdv_t::insert(std::forward<ARGS>(args)...), this );
  204|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  205|       |
  206|      0|    /*_FORCE_COVER_START_*/template <typename... ARGS>
  207|      0|    /*_FORCE_COVER_START_*/iterator erase(ARGS &&... args) {
  208|      0|      ++revision;
  209|      0|      return iterator( stdv_t::erase(std::forward<ARGS>(args)...), this );
  210|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  211|       |
  212|      0|    /*_FORCE_COVER_START_*/template <typename... ARGS>
  213|      0|    /*_FORCE_COVER_START_*/iterator emplace(ARGS &&... args) {
  214|      0|      ++revision;
  215|      0|      return iterator( stdv_t::emplace(std::forward<ARGS>(args)...), this );
  216|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  217|       |
  218|      0|    /*_FORCE_COVER_START_*/template <typename... ARGS>
  219|      4|    /*_FORCE_COVER_START_*/void emplace_back(ARGS &&... args) {
  220|      4|      stdv_t::emplace_back(std::forward<ARGS>(args)...);
  221|      4|      revision++;
  222|      4|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  223|       |  };
  224|       |
  225|       |  /// Build a specialized debug wrapper for emp::vector<bool>
  226|       |  template <typename... Ts>
  227|       |  class vector<bool, Ts...> : public std::vector<bool,Ts...> {
  228|       |  private:
  229|       |    using this_t = emp::vector<bool,Ts...>;
  230|       |    using stdv_t = std::vector<bool,Ts...>;
  231|       |
  232|       |    /// Setup a threshold; if we try to make a vector bigger than MAX_SIZE, throw a warning.
  233|       |    constexpr static const size_t MAX_SIZE = 2000000001;
  234|       |
  235|       |  public:
  236|       |    using iterator = typename stdv_t::iterator;
  237|       |    using const_iterator = typename stdv_t::const_iterator;
  238|       |    using value_type = bool;
  239|       |    using size_type = typename stdv_t::size_type;
  240|       |    using reference = typename stdv_t::reference;
  241|       |    using const_reference = typename stdv_t::const_reference;
  242|       |
  243|       |    vector() : stdv_t() {};
  244|      1|    vector(const this_t & _in) : stdv_t(_in) {};
  245|       |    vector(size_t size) : stdv_t(size) { emp_assert(size < MAX_SIZE, size); }
  246|      1|    vector(size_t size, bool val) : stdv_t(size, val) { emp_assert(size < MAX_SIZE, size); }
  247|       |    vector(std::initializer_list<bool> in_list) : stdv_t(in_list) { ; }
  248|       |    vector(const stdv_t & in) : stdv_t(in) { ; }         // Emergency fallback conversion.
  249|      0|    /*_FORCE_COVER_START_*/template <typename InputIt>
  250|      0|    vector(InputIt first, InputIt last) : stdv_t(first, last){;}/*_FORCE_COVER_END_*/
  251|       |
  252|       |
  253|       |    // operator stdv_t &() { return v; }
  254|       |    // operator const stdv_t &() const { return v; }
  255|       |
  256|       |    void resize(size_t new_size) { emp_assert(new_size < MAX_SIZE, new_size); stdv_t::resize(new_size); }
  257|       |    void resize(size_t new_size, bool val) {
  258|       |      emp_assert(new_size < MAX_SIZE, new_size);
  259|       |      stdv_t::resize(new_size, val);
  260|       |    }
  261|       |    this_t & operator=(const this_t &) = default;
  262|       |
  263|    467|    auto operator[](size_t pos) -> decltype(stdv_t::operator[](pos)) {
  264|    467|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  265|    467|      return stdv_t::operator[](pos);
  266|    467|    }
  267|       |
  268|  1.00k|    bool operator[](size_t pos) const {
  269|  1.00k|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  270|  1.00k|      return stdv_t::operator[](pos);
  271|  1.00k|    }
  272|       |
  273|       |    auto & back() { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }
  274|       |    bool back() const { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }
  275|       |    auto & front() { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }
  276|       |    bool front() const { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }
  277|       |
  278|       |    void pop_back() {
  279|       |      emp_assert(stdv_t::size() > 0, stdv_t::size());
  280|       |      stdv_t::pop_back();
  281|       |    }
  282|       |  };
  283|       |
  284|       |}
  285|       |
  286|       |// A crude, generic printing function for vectors.
  287|      0|/*_FORCE_COVER_START_*/template <typename T, typename... Ts>
  288|      0|std::ostream & operator<<(std::ostream & out, const emp::vector<T,Ts...> & v) {
  289|      0|  for (const T & x : v) out << x << " ";
  290|      0|  return out;
  291|       |}/*_FORCE_COVER_END_*/
  292|       |
  293|      0|/*_FORCE_COVER_START_*/template <typename T, typename... Ts>
  294|      0|std::istream & operator>>(std::istream & is, emp::vector<T,Ts...> & v) {
  295|      0|  for (T & x : v) is >> x;
  296|      0|  return is;
  297|       |}/*_FORCE_COVER_END_*/
  298|       |
  299|       |#endif
  300|       |
  301|       |// namespace emp {
  302|       |//   template<typename T, typename... Ts> struct TypeID< emp::vector<T,Ts...> > {
  303|       |//     static std::string GetName() {
  304|       |//       using simple_vt = emp::vector<T>;
  305|       |//       using full_vt = emp::vector<T,Ts...>;
  306|       |//       if (std::is_same<simple_vt,full_vt>::value) {
  307|       |//         return "emp::vector<" + TypeID<T>::GetName() + ">";
  308|       |//       }
  309|       |//       return "emp::vector<" + TypeID<TypePack<T,Ts...>>::GetTypes() + ">";
  310|       |//     }
  311|       |//   };
  312|       |// }
  313|       |
  314|       |#endif
  315|       |

/home/emily/repos/Empirical_MoreTests/coverage_source/meta/TypeID.h:
    1|       |//  This file is part of Empirical, https://github.com/devosoft/Empirical
    2|       |//  Copyright (C) Michigan State University, 2016.
    3|       |//  Released under the MIT Software license; see doc/LICENSE
    4|       |//
    5|       |//  TypeID provides an easy way to convert types to strings.
    6|       |//
    7|       |//
    8|       |//  Developer notes:
    9|       |//  * Fill out remaining standard library classes (as possible)
   10|       |//  * Default to type_traits typeid rather than Unknown
   11|       |
   12|       |#ifndef EMP_TYPE_ID_H
   13|       |#define EMP_TYPE_ID_H
   14|       |
   15|       |#include <sstream>
   16|       |#include <string>
   17|       |
   18|       |#include "../base/vector.h"
   19|       |#include "TypePack.h"
   20|       |
   21|       |
   22|       |namespace emp {
   23|       |
   24|       |  // Generic TypeID structure for when none of the specialty cases trigger.
   25|       |  template<typename T> struct TypeID {
   26|       |    template<typename TEST> using TypeIDFilter = decltype(&TEST::TypeID);
   27|      0|    struct UnknownID { /*_FORCE_COVER_START_*/static std::string TypeID() { return "Unknown"; }/*_FORCE_COVER_END_*/ };
   28|      0|    /*_FORCE_COVER_START_*/static std::string GetName() {
   29|      0|      using print_t = typename TypePack<T,UnknownID>::template find_t<TypeIDFilter>;
   30|      0|      return print_t::TypeID();
   31|       |    }/*_FORCE_COVER_END_*/
   32|       |  };
   33|       |
   34|       |  // Built-in types.
   35|      0|  template<> struct TypeID<void> { static std::string GetName() { return "void"; } };
   36|       |
   37|      0|  template<> struct TypeID<bool> { static std::string GetName() { return "bool"; } };
   38|      0|  template<> struct TypeID<double> { static std::string GetName() { return "double"; } };
   39|      0|  template<> struct TypeID<float> { static std::string GetName() { return "float"; } };
   40|       |
   41|      0|  template<> struct TypeID<char> { static std::string GetName() { return "char"; } };
   42|      0|  template<> struct TypeID<char16_t> { static std::string GetName() { return "char16_t"; } };
   43|      0|  template<> struct TypeID<char32_t> { static std::string GetName() { return "char32_t"; } };
   44|       |
   45|      0|  template<> struct TypeID<int8_t>  { static std::string GetName() { return "int8_t"; } };
   46|      0|  template<> struct TypeID<int16_t> { static std::string GetName() { return "int16_t"; } };
   47|      0|  template<> struct TypeID<int32_t> { static std::string GetName() { return "int32_t"; } };
   48|      0|  template<> struct TypeID<int64_t> { static std::string GetName() { return "int64_t"; } };
   49|      0|  template<> struct TypeID<uint8_t>  { static std::string GetName() { return "uint8_t"; } };
   50|      0|  template<> struct TypeID<uint16_t> { static std::string GetName() { return "uint16_t"; } };
   51|      0|  template<> struct TypeID<uint32_t> { static std::string GetName() { return "uint32_t"; } };
   52|      0|  template<> struct TypeID<uint64_t> { static std::string GetName() { return "uint64_t"; } };
   53|       |
   54|       |  // Check for type attributes...
   55|       |  template<typename T> struct TypeID<T*> {
   56|       |    static std::string GetName() { return TypeID<T>::GetName() + '*'; }
   57|       |  };
   58|       |
   59|       |  // Tools for using TypePack
   60|       |  template<typename T, typename... Ts> struct TypeID<emp::TypePack<T,Ts...>> {
   61|       |    static std::string GetTypes() {
   62|       |      std::string out = TypeID<T>::GetName();
   63|       |      if (sizeof...(Ts) > 0) out += ",";
   64|       |      out += TypeID<emp::TypePack<Ts...>>::GetTypes();
   65|       |      return out;
   66|       |    }
   67|       |	  static std::string GetName() {
   68|       |      std::string out = "emp::TypePack<";
   69|       |	    out += GetTypes();
   70|       |	    out += ">";
   71|       |	    return out;
   72|       |    }
   73|       |  };
   74|       |  template<> struct TypeID< emp::TypePack<> > {
   75|      0|    static std::string GetTypes() { return ""; }
   76|      0|    static std::string GetName() { return "emp::TypePack<>"; }
   77|       |  };
   78|       |
   79|       |  // Generic TemplateID structure for when none of the specialty cases trigger.
   80|       |  template <typename T> struct TemplateID {
   81|      0|    /*_FORCE_COVER_START_*/static std::string GetName() { return "UnknownTemplate"; }/*_FORCE_COVER_END_*/
   82|       |  };
   83|       |
   84|       |  template<template <typename...> class TEMPLATE, typename... Ts>
   85|       |  struct TypeID<TEMPLATE<Ts...>> {
   86|       |    static std::string GetName() {
   87|       |      return TemplateID<TEMPLATE<Ts...>>::GetName()
   88|       |            + '<' + TypeID<emp::TypePack<Ts...>>::GetTypes() + '>';
   89|       |    }
   90|       |  };
   91|       |}
   92|       |
   93|       |
   94|       |namespace emp{
   95|       |
   96|       |  // Standard library types.
   97|      0|  template<> struct TypeID<std::string> { static std::string GetName() { return "std::string"; } };
   98|       |
   99|       |  // Standard library templates.
  100|       |  //  template <typename... Ts> struct TemplateID<std::array<Ts...>> { static std::string GetName() { return "array"; } };
  101|       |
  102|       |  template<typename T, typename... Ts> struct TypeID< emp::vector<T,Ts...> > {
  103|       |    static std::string GetName() {
  104|       |      using simple_vt = emp::vector<T>;
  105|       |      using full_vt = emp::vector<T,Ts...>;
  106|       |      if (std::is_same<simple_vt,full_vt>::value) {
  107|       |        return "emp::vector<" + TypeID<T>::GetName() + ">";
  108|       |      }
  109|       |      return "emp::vector<" + TypeID<TypePack<T,Ts...>>::GetTypes() + ">";
  110|       |    }
  111|       |  };
  112|       |
  113|       |}
  114|       |
  115|       |#endif
  116|       |

/home/emily/repos/Empirical_MoreTests/coverage_source/meta/TypePack.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file  TypePack.h
    7|       | *  @brief A set of types that can be manipulated at compile time (good for metaprogramming)
    8|       | *
    9|       | *  TypePacks are static structues that provide a large set of mechanisms to access and adjust
   10|       | *  the included types.
   11|       | *
   12|       | *  To create a typepack, just pass in zero or more types into the TypePack templete.
   13|       | *
   14|       | *    using my_pack = emp::TypePack<int, std::string, double>;
   15|       | *
   16|       | *  After manipulations, you can apply a type pack using the apply<> member template.  E.g.,
   17|       | *
   18|       | *    my_pack::resize<5,char>::reverse::apply<std::tuple> my_tuple;
   19|       | *
   20|       | *  ...would create a variable of type std::tuple<char, char, double, std::string, int>.
   21|       | *
   22|       | *
   23|       | *  Member functions include (all of which are constexpr):
   24|       | *    Has<T>()          - Return true/false: Is T is part of the pack?
   25|       | *    Count<T>()        - Return number of times T is in the pack.
   26|       | *    GetID<T>()        - Return first position of T in the pack, (or -1 if none).
   27|       | *    GetSize()         - Return total number of types in this pack.
   28|       | *    IsEmpty()         - Return true/false: Is this pack empty?
   29|       | *    IsUnique()        - Return true/false: are all types in pack are distinct?
   30|       | *
   31|       | *  Type accessors:
   32|       | *    get<POS>          - Type at position POS in the pack.
   33|       | *    first_t           - Type of first position in the pack.
   34|       | *    last_t            - Type of last position in the pack.
   35|       | *    select<Ps...>     - Create a new pack with types from selected position.
   36|       | *
   37|       | *  Type manipulations:
   38|       | *    set<POS, T>       - Change types at position POS to T.
   39|       | *    push_front<Ts...> - Add any number of types Ts to the front of the pack.
   40|       | *    push_back<Ts...>  - Add any number of types Ts to the back of the pack.
   41|       | *    pop               - Pack with first type missing.
   42|       | *    popN<N>           - Pack with first N types missing.
   43|       | *    shrink<N>         - Pack with ONLY first N types.
   44|       | *    resize<N,D>       - Resize pack to N types; if N greater than current size, pad with D.
   45|       | *    merge<P>          - Append all of pack P to the end of this pack.
   46|       | *    reverse           - Reverse the order of types in this pack.
   47|       | *    rotate            - Move the first type in pack to the end.
   48|       | *
   49|       | *  Applications:
   50|       | *    apply<T>          - Take template T and apply these types as its arguments.
   51|       | *    to_function_t<T>  - Convert to a function type, with return type T and arg types from pack.
   52|       | *    filter<FILTER>    - Keep only those types, T, that can legally form FILTER<T> and does not
   53|       | *                        have a FILTER<T>::value == false.
   54|       | *    find<FILTER>      - Convert to first type, T, that can legally form FILTER<T> and does not
   55|       | *                        have a FILTER<T>::value == false.
   56|       | *    wrap<WRAPPER>     - Convert to TypePack where all members are run through WRAPPER
   57|       | *
   58|       | *
   59|       | *  Developer notes:
   60|       | *    - GetIDPack could return an IntPack of ALL ID's for a type that appears more than once.
   61|       | */
   62|       |
   63|       |#ifndef EMP_TYPE_PACK_H
   64|       |#define EMP_TYPE_PACK_H
   65|       |
   66|       |#include "meta.h"
   67|       |
   68|       |namespace emp {
   69|       |
   70|       |  // Pre-declaration of TypePack
   71|       |  template <typename... Ts> struct TypePack;
   72|       |
   73|       |  // Create a null type for padding.
   74|       |  struct null_t {};
   75|       |
   76|       |  // Anonymous helpers for TypePack
   77|       |  namespace {
   78|       |    // Create add N copies of the same type to the end of a TypePack.
   79|       |    template <typename START, typename T, int N>
   80|       |    struct tp_pad { using type = typename tp_pad<START,T,N-1>::type::template add<T>; };
   81|       |    template <typename START, typename T>
   82|       |    struct tp_pad<START, T,0> { using type = START; };
   83|       |
   84|       |    /// Helper for shifting a specified number of types to TypePack T1 from TypePack T2.
   85|       |    /// Example: to shrink, move the specified number of types to empty TypePack and return it.
   86|       |    ///          to merge, move all of one TypePack over to the other and return it.
   87|       |    template <int S, typename T1, typename T2>
   88|       |    struct tp_shift {
   89|       |      using move_t = typename T2::first_t;
   90|       |      using inc_t = typename T1::template add<move_t>;
   91|       |      using dec_t = typename T2::pop;
   92|       |      using type1 = typename tp_shift<S-1, inc_t, dec_t>::type1;
   93|       |      using type2 = typename tp_shift<S-1, inc_t, dec_t>::type2;
   94|       |    };
   95|       |    template <typename T1, typename T2>
   96|       |    struct tp_shift<0, T1, T2> {
   97|       |      using type1 = T1;
   98|       |      using type2 = T2;
   99|       |    };
  100|       |
  101|       |    // Filters create a TypePack with the element if the filter is true, empty if false.
  102|       |    template <typename T, bool> struct tp_filter1 { using type=TypePack<T>; };
  103|       |    template <typename T> struct tp_filter1<T,false> { using type=TypePack<>; };
  104|       |
  105|       |    /// Remove types from a TypePack that can't satisfy a filter.
  106|       |    template <typename T, template <typename...> class FILTER, int N>
  107|       |    struct tp_filter {
  108|       |      using cur_t = typename T::first_t;                                 // Isolate the first type
  109|       |      using other_tp = typename T::pop;                                  // Isolate remaining types
  110|       |      constexpr static bool cur_result = test_type<FILTER,cur_t>();      // Run filter of cur type
  111|       |      using cur_ftp = typename tp_filter1<cur_t, cur_result>::type;      // Use cur type if true
  112|       |      using other_ftp = typename tp_filter<other_tp, FILTER, N-1>::type; // Recurse
  113|       |      using type = typename cur_ftp::template merge< other_ftp >;        // Merge
  114|       |    };
  115|       |    template <typename T, template <typename...> class FILTER>
  116|       |      struct tp_filter<T,FILTER,0> { using type = TypePack<>; };
  117|       |
  118|       |    template <typename T, template <typename...> class FILTER>
  119|       |      using tp_filter_t = typename tp_filter<T,FILTER,T::SIZE>::type;
  120|       |
  121|       |    // Wrappers create a TypePack with the wrapped element if the filter is true, empty if false.
  122|       |    template <typename T, template <typename...> class W, bool> struct tp_wrap1
  123|       |      { using type=TypePack<W<T>>; };
  124|       |    template <typename T, template <typename...> class W> struct tp_wrap1<T,W,false>
  125|       |      { using type=TypePack<>; };
  126|       |
  127|       |    /// Wrap all types in a TypePack in a template; remove any that can't be wrapped.
  128|       |    template <typename T, template <typename...> class W, int N> struct tp_wrap {
  129|       |      using cur_t = typename T::first_t;                               // Isolate the first type
  130|       |      using other_tp = typename T::pop;                                // Isolate remaining types
  131|       |      constexpr static bool cur_result = test_type<W,cur_t>();         // Use wrap to filter cur type
  132|       |      using cur_ftp = typename tp_wrap1<cur_t, W, cur_result>::type;   // Use cur type if true
  133|       |      using other_ftp = typename tp_wrap<other_tp, W, N-1>::type;      // Recurse
  134|       |      using type = typename cur_ftp::template merge< other_ftp >;      // Merge
  135|       |    };
  136|       |    template <typename T, template <typename...> class W>
  137|       |      struct tp_wrap<T,W,0> { using type = TypePack<>; };
  138|       |
  139|       |    template <typename T, template <typename...> class W>
  140|       |      using tp_wrap_t = typename tp_wrap<T,W,T::SIZE>::type;
  141|       |  }
  142|       |
  143|       |  template <typename T, int N> using TypePackFill = typename tp_pad<TypePack<>,T,N>::type;
  144|       |
  145|       |  // Specialized TypePack with at least one type.
  146|       |  template <typename T1, typename... Ts>
  147|       |  struct TypePack<T1, Ts...> {
  148|       |    /// Return a bool indicating whether the specified type is present.
  149|      0|    /*_FORCE_COVER_START_*/template <typename T> constexpr static bool Has() { return has_type<T,T1,Ts...>(); }/*_FORCE_COVER_END_*/
  150|       |
  151|       |    /// Count the number of instances of the specified type.
  152|      0|    /*_FORCE_COVER_START_*/template <typename T> constexpr static size_t Count() { return count_type<T,T1,Ts...>(); }/*_FORCE_COVER_END_*/
  153|       |
  154|       |    /// Return the position of the specified type.
  155|      0|    /*_FORCE_COVER_START_*/template <typename T> constexpr static int GetID() { return get_type_index<T,T1,Ts...>(); }/*_FORCE_COVER_END_*/
  156|       |
  157|       |    /// Return the position of the type of owner.
  158|      0|    /*_FORCE_COVER_START_*/template <typename T> constexpr static int GetID(const T &) { return get_type_index<T,T1,Ts...>(); }/*_FORCE_COVER_END_*/
  159|       |
  160|       |    /// Set to the number of types in this pack.
  161|       |    constexpr static int SIZE = 1+sizeof...(Ts);
  162|       |
  163|       |    /// Return the number of types in this pack.
  164|       |    constexpr static int GetSize() { return SIZE; }
  165|       |
  166|       |    /// Return bool indicating if there are any types in this pack.
  167|       |    constexpr static bool IsEmpty() { return false; }
  168|       |
  169|       |    /// Return bool indicating if all types in this pack are different from each other.
  170|       |    constexpr static bool IsUnique() { return has_unique_types<T1,Ts...>(); }
  171|       |
  172|       |    /// Get the type associated with a specified position in the pack.
  173|       |    template <int POS> using get = pack_id<POS, T1, Ts...>;
  174|       |
  175|       |    // Other type lookups
  176|       |
  177|       |    /// What is the full type of this TypePack?
  178|       |    // (mostly a helper for the code below)
  179|       |    using this_t = TypePack<T1, Ts...>;
  180|       |
  181|       |    /// What is the first type in this TypePack?
  182|       |    using first_t = T1;
  183|       |
  184|       |    /// What is the final type in this TypePack?
  185|       |    using last_t = last_type<T1,Ts...>;
  186|       |
  187|       |    // Modifications
  188|       |
  189|       |    /// Push a new type onto the front of this TypePack.
  190|       |    template <typename... T> using push_front = TypePack<T...,T1,Ts...>;
  191|       |
  192|       |    /// Push a new type onto the back of this TypePack.
  193|       |    template <typename... T> using push_back = TypePack<T1,Ts...,T...>;
  194|       |
  195|       |    /// Push a new type onto the back of this TypePack.
  196|       |    template <typename... T> using add = TypePack<T1,Ts...,T...>;    // Same as push_back_t...
  197|       |
  198|       |    /// Remove the first type from this TypePack and return the rest.
  199|       |    using pop = TypePack<Ts...>;
  200|       |    template <int N> using popN = typename tp_shift<N, TypePack<>, this_t>::type2;
  201|       |
  202|       |    /// Reduce the size of this TypePack down to N.
  203|       |    template <int N> using shrink = typename tp_shift<N, TypePack<>, this_t>::type1;
  204|       |
  205|       |    /// Add N new entries onto TypePack, all of provided type T.
  206|       |    template <typename T, int N=1> using pad = typename tp_pad<this_t,T,N>::type;
  207|       |
  208|       |    /// Make this TypePack the specified size, padding with provided type T.
  209|       |    template <int N, typename DEFAULT=null_t>
  210|       |      using resize = typename pad<DEFAULT,(N>SIZE)?(N-SIZE):0>::template shrink<N>;
  211|       |
  212|       |    /// Join this TypePack with another TypePack.
  213|       |    template <typename IN> using merge = typename tp_shift<IN::SIZE, this_t, IN>::type1;
  214|       |
  215|       |    /// Rearrange types in TypePack into reverse order.
  216|       |    using reverse = typename pop::reverse::template push_back<T1>;
  217|       |
  218|       |    /// Rotate types through typepack by the specified number of steps.
  219|       |    using rotate = typename pop::template push_back<T1>;
  220|       |
  221|       |    /// Set the type at the specified position to the new type provided.  Return as new TypePack.
  222|       |    template <int ID, typename T>
  223|       |      using set = typename shrink<ID>::template push_back<T>::template merge<popN<ID+1>>;
  224|       |
  225|       |    /// Choose a set of specific positions.  Return as new TypePack.
  226|       |    template <int... Ps> using select = TypePack< get<Ps>... >;
  227|       |
  228|       |    /// Convert to a function signature with a specified return type.
  229|       |    template <typename RETURN_T> using to_function_t = RETURN_T(T1,Ts...);
  230|       |
  231|       |    /// Apply to a specified template with TypePack as template arguments.
  232|       |    template <template <typename...> class TEMPLATE> using apply = TEMPLATE<T1, Ts...>;
  233|       |
  234|       |    /// Remove all types that cannot pass a filter.  Return as new TypePack.
  235|       |    template <template <typename...> class FILTER> using filter = tp_filter_t<this_t, FILTER>;
  236|       |
  237|       |    /// Return the first type that satisfies a filter.
  238|       |    template <template <typename...> class FILTER>
  239|       |      using find_t = typename tp_filter_t<this_t, FILTER>::first_t;
  240|       |
  241|       |    /// Wrap all types in a specified wrapper template.
  242|       |    template <template <typename...> class WRAPPER> using wrap = tp_wrap_t<this_t, WRAPPER>;
  243|       |  };
  244|       |
  245|       |  // Specialized TypePack with no types.
  246|       |  template <>
  247|       |  struct TypePack<> {
  248|      0|    /*_FORCE_COVER_START_*/template <typename T> constexpr static bool Has() { return false; }/*_FORCE_COVER_END_*/
  249|      0|    /*_FORCE_COVER_START_*/template <typename T> constexpr static size_t Count() { return 0; }/*_FORCE_COVER_END_*/
  250|       |
  251|       |    // GetID() NOT IMPLEMENTED since no ID's are available.
  252|       |    constexpr static int SIZE = 0;
  253|      0|    constexpr static int GetSize() { return 0; }
  254|      0|    constexpr static bool IsEmpty() { return true; }
  255|      0|    constexpr static bool IsUnique() { return true; }
  256|       |
  257|       |    // pop_t not implemented, since no types are available.
  258|       |
  259|       |    using this_t = TypePack<>;
  260|       |    using first_t = null_t;
  261|       |    using last_t = null_t;
  262|       |
  263|       |    template <typename... T> using push_front = TypePack<T...>;
  264|       |    template <typename... T> using push_back = TypePack<T...>;
  265|       |    template <typename... T> using add = TypePack<T...>;
  266|       |
  267|       |    // In both of these cases, N had better be zero... but no easy way to assert.
  268|       |    template <int N> using popN = this_t;
  269|       |    template <int N> using shrink = this_t;
  270|       |
  271|       |    template <typename T, int N=1> using pad = typename tp_pad<this_t,T,N>::type;
  272|       |    template <int N, typename DEFAULT=null_t> using resize = pad<DEFAULT,N>;
  273|       |
  274|       |    template <typename IN> using merge = IN;
  275|       |    using reverse = this_t;
  276|       |    using rotate = this_t;
  277|       |
  278|       |    template <typename RETURN_T> using to_function_t = RETURN_T();
  279|       |
  280|       |    template <template <typename...> class TEMPLATE> using apply = TEMPLATE<>;
  281|       |
  282|       |    // There's nothing to filter, so return this_t (TypePack<>) or null_t
  283|       |    template <template <typename...> class FILTER> using filter = this_t;
  284|       |    template <template <typename...> class FILTER> using find_t = null_t;
  285|       |    template <template <typename...> class WRAPPER> using wrap = this_t;
  286|       |  };
  287|       |}
  288|       |
  289|       |#endif
  290|       |

/home/emily/repos/Empirical_MoreTests/tests/test_base.cc:
    1|       |//  This file is part of Empirical, https://github.com/devosoft/Empirical
    2|       |//  Copyright (C) Michigan State University, 2016-2018.
    3|       |//  Released under the MIT Software license; see doc/LICENSE
    4|       |//
    5|       |//  Tests for files in the base/ folder.
    6|       |
    7|      0|#define EMP_DECORATE(X) [X]
    8|      0|#define EMP_DECORATE_PAIR(X,Y) [X-Y]
    9|       |#define CATCH_CONFIG_MAIN
   10|       |
   11|       |#include "../third-party/Catch/single_include/catch.hpp"
   12|       |
   13|       |#include <sstream>
   14|       |#include <string>
   15|       |
   16|       |#include "base/array.h"
   17|       |#include "base/assert.h"
   18|       |#include "base/errors.h"
   19|       |#include "base/macro_math.h"
   20|       |#include "base/macros.h"
   21|       |#include "base/Ptr.h"
   22|       |#include "base/vector.h"
   23|       |
   24|       |
   25|       |// "Macros testing macros...Oh dear..."
   26|       |#undef EMP_TEST_MACRO
   27|      0|#define EMP_TEST_MACRO( MACRO, EXP_RESULT )                             \
   28|    185|  do {                                                                  \
   29|    185|    std::string result = std::string(EMP_STRINGIFY( MACRO ));           \
   30|    185|    REQUIRE(result == EXP_RESULT);                                      \
   31|    185|  } while (false)
   32|       |
   33|       |
   34|       |TEST_CASE("Test array", "[base]")
   35|      1|{
   36|      1|  constexpr int A_SIZE = 50;
   37|      1|  emp::array<int, A_SIZE> test_array;
   38|      1|
   39|     51|  for (size_t i = 0; i < A_SIZE; i++) {
   40|     50|    test_array[i] = (int) (i * i);
   41|     50|  }
   42|      1|
   43|      1|  int sum = 0;
   44|     51|  for (size_t i = 0; i < A_SIZE; i++) {
   45|     50|    sum += test_array[i];
   46|     50|  }
   47|      1|
   48|      1|  REQUIRE(sum == 40425);
   49|      1|}
   50|       |
   51|       |
   52|       |TEST_CASE("Test macro_math", "[base]")
   53|      1|{
   54|      1|
   55|      1|  // Test converting between binary, decimal, and sum formats.
   56|      1|  EMP_TEST_MACRO( EMP_DEC_TO_BIN(9), "0, 0, 0, 0, 0, 0, 1, 0, 0, 1");
   57|      1|  EMP_TEST_MACRO( EMP_DEC_TO_BIN(91), "0, 0, 0, 1, 0, 1, 1, 0, 1, 1");
   58|      1|  EMP_TEST_MACRO( EMP_DEC_TO_BIN(999), "1, 1, 1, 1, 1, 0, 0, 1, 1, 1");
   59|      1|
   60|      1|  EMP_TEST_MACRO( EMP_BIN_TO_DEC(0,0,0,0,0,0,1,0,1,1), "11");
   61|      1|  EMP_TEST_MACRO( EMP_BIN_TO_DEC(0,0,0,1,0,1,1,0,1,1), "91");
   62|      1|  EMP_TEST_MACRO( EMP_BIN_TO_DEC(1,0,1,0,1,0,1,0,1,0), "682");
   63|      1|
   64|      1|  EMP_TEST_MACRO( EMP_BIN_TO_SUM(0,0,0,1,0,1,1,0,1,1), "0, 0, 0, 64, 0, 16, 8, 0, 2, 1");
   65|      1|  EMP_TEST_MACRO( EMP_DEC_TO_SUM(91), "0, 0, 0, 64, 0, 16, 8, 0, 2, 1");
   66|      1|
   67|      1|  EMP_TEST_MACRO( EMP_BIN_TO_PACK(0,0,0,1,0,1,1,0,1,1), "(64, 16, 8, 2, 1)");
   68|      1|  EMP_TEST_MACRO( EMP_DEC_TO_PACK(91), "(64, 16, 8, 2, 1)");
   69|      1|
   70|      1|  // Test Boolean logic
   71|      1|  EMP_TEST_MACRO( EMP_NOT(0), "1" );
   72|      1|  EMP_TEST_MACRO( EMP_NOT(EMP_NOT(0)), "0" );
   73|      1|
   74|      1|  EMP_TEST_MACRO( EMP_BIT_EQU(0,0), "1" );
   75|      1|  EMP_TEST_MACRO( EMP_BIT_EQU(0,1), "0" );
   76|      1|  EMP_TEST_MACRO( EMP_BIT_EQU(1,0), "0" );
   77|      1|  EMP_TEST_MACRO( EMP_BIT_EQU(1,1), "1" );
   78|      1|
   79|      1|  EMP_TEST_MACRO( EMP_BIT_LESS(0,0), "0" );
   80|      1|  EMP_TEST_MACRO( EMP_BIT_LESS(0,1), "1" );
   81|      1|  EMP_TEST_MACRO( EMP_BIT_LESS(1,0), "0" );
   82|      1|  EMP_TEST_MACRO( EMP_BIT_LESS(1,1), "0" );
   83|      1|
   84|      1|  EMP_TEST_MACRO( EMP_BIT_GTR(0,0), "0" );
   85|      1|  EMP_TEST_MACRO( EMP_BIT_GTR(0,1), "0" );
   86|      1|  EMP_TEST_MACRO( EMP_BIT_GTR(1,0), "1" );
   87|      1|  EMP_TEST_MACRO( EMP_BIT_GTR(1,1), "0" );
   88|      1|
   89|      1|  // Test conditionals.
   90|      1|  EMP_TEST_MACRO( EMP_IF_impl_0(abc), "~, abc" );
   91|      1|  EMP_TEST_MACRO( EMP_IF_impl_1(abc), "EMP_IF_impl_1(abc)" );
   92|      1|  EMP_TEST_MACRO( EMP_IF(0, A, B), "B" );
   93|      1|  EMP_TEST_MACRO( EMP_IF(1, A, B), "A" );
   94|      1|
   95|      1|  // Test comparisons
   96|      1|  EMP_TEST_MACRO( EMP_COMPARE(10,20), "B" );
   97|      1|  EMP_TEST_MACRO( EMP_COMPARE(1023,1022), "A" );
   98|      1|  EMP_TEST_MACRO( EMP_COMPARE(1000,999), "A" );
   99|      1|  EMP_TEST_MACRO( EMP_COMPARE(678,678), "X" );
  100|      1|
  101|      1|  EMP_TEST_MACRO( EMP_EQU(5,5), "1" );
  102|      1|  EMP_TEST_MACRO( EMP_EQU(2,5), "0" );
  103|      1|  EMP_TEST_MACRO( EMP_EQU(5,8), "0" );
  104|      1|  EMP_TEST_MACRO( EMP_EQU(8,5), "0" );
  105|      1|  EMP_TEST_MACRO( EMP_EQU(5,2), "0" );
  106|      1|
  107|      1|  EMP_TEST_MACRO( EMP_LESS(5,5), "0" );
  108|      1|  EMP_TEST_MACRO( EMP_LESS(2,5), "1" );
  109|      1|  EMP_TEST_MACRO( EMP_LESS(5,8), "1" );
  110|      1|  EMP_TEST_MACRO( EMP_LESS(8,5), "0" );
  111|      1|  EMP_TEST_MACRO( EMP_LESS(5,2), "0" );
  112|      1|
  113|      1|  EMP_TEST_MACRO( EMP_LESS_EQU(5,5), "1" );
  114|      1|  EMP_TEST_MACRO( EMP_LESS_EQU(2,5), "1" );
  115|      1|  EMP_TEST_MACRO( EMP_LESS_EQU(5,8), "1" );
  116|      1|  EMP_TEST_MACRO( EMP_LESS_EQU(8,5), "0" );
  117|      1|  EMP_TEST_MACRO( EMP_LESS_EQU(5,2), "0" );
  118|      1|
  119|      1|  EMP_TEST_MACRO( EMP_GTR(5,5), "0" );
  120|      1|  EMP_TEST_MACRO( EMP_GTR(2,5), "0" );
  121|      1|  EMP_TEST_MACRO( EMP_GTR(5,8), "0" );
  122|      1|  EMP_TEST_MACRO( EMP_GTR(8,5), "1" );
  123|      1|  EMP_TEST_MACRO( EMP_GTR(5,2), "1" );
  124|      1|
  125|      1|  EMP_TEST_MACRO( EMP_GTR_EQU(5,5), "1" );
  126|      1|  EMP_TEST_MACRO( EMP_GTR_EQU(2,5), "0" );
  127|      1|  EMP_TEST_MACRO( EMP_GTR_EQU(5,8), "0" );
  128|      1|  EMP_TEST_MACRO( EMP_GTR_EQU(8,5), "1" );
  129|      1|  EMP_TEST_MACRO( EMP_GTR_EQU(5,2), "1" );
  130|      1|
  131|      1|  EMP_TEST_MACRO( EMP_NEQU(5,5), "0" );
  132|      1|  EMP_TEST_MACRO( EMP_NEQU(2,5), "1" );
  133|      1|  EMP_TEST_MACRO( EMP_NEQU(5,8), "1" );
  134|      1|  EMP_TEST_MACRO( EMP_NEQU(8,5), "1" );
  135|      1|  EMP_TEST_MACRO( EMP_NEQU(5,2), "1" );
  136|      1|
  137|      1|
  138|      1|
  139|      1|  // Test other helper math functions.
  140|      1|  EMP_TEST_MACRO( EMP_MATH_VAL_TIMES_0(222), "0" );
  141|      1|  EMP_TEST_MACRO( EMP_MATH_VAL_TIMES_1(222), "222" );
  142|      1|
  143|      1|  EMP_TEST_MACRO( EMP_MATH_BIN_TIMES_0(0,0,1,0,1,0,1,0,1,0), "0, 0, 0, 0, 0, 0, 0, 0, 0, 0" );
  144|      1|  EMP_TEST_MACRO( EMP_MATH_BIN_TIMES_1(0,0,1,0,1,0,1,0,1,0), "0, 0, 1, 0, 1, 0, 1, 0, 1, 0" );
  145|      1|
  146|      1|  EMP_TEST_MACRO( EMP_MATH_COUNT_BITS(1, 1), "2");
  147|      1|  EMP_TEST_MACRO( EMP_MATH_COUNT_BITS(1, N), "0");
  148|      1|  EMP_TEST_MACRO( EMP_MATH_COUNT_BITS(0, N), "N");
  149|      1|
  150|      1|  EMP_TEST_MACRO( EMP_MATH_GET_CARRY(2), "1");
  151|      1|  EMP_TEST_MACRO( EMP_MATH_CLEAR_CARRY(2), "0");
  152|      1|
  153|      1|  // Now in combination...
  154|      1|  EMP_TEST_MACRO( EMP_MATH_COUNT_BITS(EMP_MATH_CLEAR_CARRY(1), EMP_MATH_GET_CARRY(2)), "2" );
  155|      1|
  156|      1|  // Basic Addition...
  157|      1|  EMP_TEST_MACRO( EMP_ADD(1, 2), "3");
  158|      1|  EMP_TEST_MACRO( EMP_ADD(5, 5), "10");
  159|      1|  EMP_TEST_MACRO( EMP_ADD(7, 7), "14");
  160|      1|  EMP_TEST_MACRO( EMP_ADD(111, 112), "223");
  161|      1|  EMP_TEST_MACRO( EMP_ADD(127, 1), "128");
  162|      1|  EMP_TEST_MACRO( EMP_ADD(123, 789), "912");
  163|      1|  EMP_TEST_MACRO( EMP_ADD(1023, 1), "0");      // Overflow
  164|      1|
  165|      1|  EMP_TEST_MACRO( EMP_ADD_10(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), "55" );
  166|      1|
  167|      1|  // Basic Subtraction...
  168|      1|  EMP_TEST_MACRO( EMP_SUB(10, 7), "3");
  169|      1|  EMP_TEST_MACRO( EMP_SUB(128, 1), "127");
  170|      1|  EMP_TEST_MACRO( EMP_SUB(250, 250), "0");
  171|      1|  EMP_TEST_MACRO( EMP_SUB(250, 100), "150");
  172|      1|  EMP_TEST_MACRO( EMP_SUB(91, 66), "25");
  173|      1|  EMP_TEST_MACRO( EMP_SUB(99, 100), "1023");   // Underflow
  174|      1|
  175|      1|  // Combination of add and sub
  176|      1|  EMP_TEST_MACRO( EMP_ADD( EMP_SUB(250, 100), EMP_SUB(91, 66)), "175");
  177|      1|
  178|      1|  // Shifting
  179|      1|  EMP_TEST_MACRO( EMP_SHIFTL(17), "34");
  180|      1|  EMP_TEST_MACRO( EMP_SHIFTL(111), "222");
  181|      1|  EMP_TEST_MACRO( EMP_SHIFTL(444), "888");
  182|      1|  EMP_TEST_MACRO( EMP_SHIFTL(1023), "1022");   // Overflow...
  183|      1|
  184|      1|  EMP_TEST_MACRO( EMP_SHIFTR(100), "50");
  185|      1|  EMP_TEST_MACRO( EMP_SHIFTR(151), "75");
  186|      1|
  187|      1|  EMP_TEST_MACRO( EMP_SHIFTL_X(0, 700), "700");
  188|      1|  EMP_TEST_MACRO( EMP_SHIFTL_X(5, 17),  "544");
  189|      1|  EMP_TEST_MACRO( EMP_SHIFTL_X(1, 111), "222");
  190|      1|  EMP_TEST_MACRO( EMP_SHIFTR_X(1, 100), "50");
  191|      1|  EMP_TEST_MACRO( EMP_SHIFTR_X(3, 151), "18");
  192|      1|
  193|      1|  // Inc, dec, half...
  194|      1|  EMP_TEST_MACRO( EMP_INC(20), "21");
  195|      1|  EMP_TEST_MACRO( EMP_INC(55), "56");
  196|      1|  EMP_TEST_MACRO( EMP_INC(63), "64");
  197|      1|  EMP_TEST_MACRO( EMP_INC(801), "802");
  198|      1|
  199|      1|  EMP_TEST_MACRO( EMP_DEC(20), "19");
  200|      1|  EMP_TEST_MACRO( EMP_DEC(55), "54");
  201|      1|  EMP_TEST_MACRO( EMP_DEC(63), "62");
  202|      1|  EMP_TEST_MACRO( EMP_DEC(900), "899");
  203|      1|
  204|      1|  EMP_TEST_MACRO( EMP_HALF(17), "8");
  205|      1|  EMP_TEST_MACRO( EMP_HALF(18), "9");
  206|      1|  EMP_TEST_MACRO( EMP_HALF(60), "30");
  207|      1|  EMP_TEST_MACRO( EMP_HALF(1001), "500");
  208|      1|
  209|      1|  // Multiply!
  210|      1|  EMP_TEST_MACRO( EMP_MULT(1, 1), "1");
  211|      1|  EMP_TEST_MACRO( EMP_MULT(200, 0), "0");
  212|      1|  EMP_TEST_MACRO( EMP_MULT(201, 1), "201");
  213|      1|  EMP_TEST_MACRO( EMP_MULT(10, 7), "70");
  214|      1|  EMP_TEST_MACRO( EMP_MULT(25, 9), "225");
  215|      1|  EMP_TEST_MACRO( EMP_MULT(65, 3), "195");
  216|      1|  EMP_TEST_MACRO( EMP_MULT(65, 15), "975");
  217|      1|
  218|      1|  // Bit Manipulation!
  219|      1|  EMP_TEST_MACRO( EMP_COUNT_ONES(0), "0");
  220|      1|  EMP_TEST_MACRO( EMP_COUNT_ONES(509), "8");
  221|      1|  EMP_TEST_MACRO( EMP_COUNT_ONES(1023), "10");
  222|      1|
  223|      1|  EMP_TEST_MACRO( EMP_LOG2(0), "0" );
  224|      1|  EMP_TEST_MACRO( EMP_LOG2(1), "1" );
  225|      1|  EMP_TEST_MACRO( EMP_LOG2(3), "2" );
  226|      1|  EMP_TEST_MACRO( EMP_LOG2(5), "3" );
  227|      1|  EMP_TEST_MACRO( EMP_LOG2(10), "4" );
  228|      1|  EMP_TEST_MACRO( EMP_LOG2(20), "5" );
  229|      1|  EMP_TEST_MACRO( EMP_LOG2(40), "6" );
  230|      1|  EMP_TEST_MACRO( EMP_LOG2(75), "7" );
  231|      1|  EMP_TEST_MACRO( EMP_LOG2(150), "8" );
  232|      1|  EMP_TEST_MACRO( EMP_LOG2(300), "9" );
  233|      1|  EMP_TEST_MACRO( EMP_LOG2(600), "10" );
  234|      1|
  235|      1|  // Division!
  236|      1|  EMP_TEST_MACRO( EMP_DIV_start(2), "8" );
  237|      1|  EMP_TEST_MACRO( EMP_DIV(8, 2), "4" );
  238|      1|  EMP_TEST_MACRO( EMP_DIV(100, 5), "20" );
  239|      1|  EMP_TEST_MACRO( EMP_DIV(1000, 17), "58" );
  240|      1|
  241|      1|  // Modulus!
  242|      1|  EMP_TEST_MACRO( EMP_MOD(10, 3), "1" );
  243|      1|  EMP_TEST_MACRO( EMP_MOD(127, 10), "7" );
  244|      1|  EMP_TEST_MACRO( EMP_MOD(127, 1000), "127" );
  245|      1|  EMP_TEST_MACRO( EMP_MOD(102, 3), "0" );
  246|      1|}
  247|       |
  248|       |
  249|       |
  250|       |TEST_CASE("Test macros", "[base]")
  251|      1|{
  252|      1|  EMP_TEST_MACRO( EMP_POP_ARGS_32(1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0), "3,4,5,6,7,8,9,0");
  253|      1|  EMP_TEST_MACRO( EMP_POP_ARGS(32, 1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0), "3,4,5,6,7,8,9,0");
  254|      1|  EMP_TEST_MACRO( EMP_POP_ARGS(39, 1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0), "0");
  255|      1|
  256|      1|  // Test getting a specific argument.
  257|      1|  EMP_TEST_MACRO( EMP_POP_ARGS( EMP_DEC(5), 11,12,13,14,15,16,17 ), "15,16,17");
  258|      1|  EMP_TEST_MACRO( EMP_GET_ARG(5, 11,12,13,14,15,16,17), "15");
  259|      1|
  260|      1|  // Test counting number of arguments.
  261|      1|  EMP_TEST_MACRO( EMP_COUNT_ARGS(a, b, c), "3" );
  262|      1|  EMP_TEST_MACRO( EMP_COUNT_ARGS(x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x), "600" );
  263|      1|
  264|      1|  // Make sure EMP_STRINGIFY can process macros before running
  265|      1|  EMP_TEST_MACRO( EMP_STRINGIFY(EMP_MERGE(ab, c, de, f)), "\"abcdef\"");
  266|      1|  EMP_TEST_MACRO( EMP_STRINGIFY("abcdef"), "\"\\\"abcdef\\\"\"" );
  267|      1|
  268|      1|
  269|      1|  // Test PACK manipulation
  270|      1|  EMP_TEST_MACRO( EMP_PACK_ARGS(a,b,c), "(a,b,c)");
  271|      1|  EMP_TEST_MACRO( EMP_UNPACK_ARGS((a,b,c)), "a,b,c");
  272|      1|  EMP_TEST_MACRO( EMP_PACK_POP((a,b,c)), "(b,c)");
  273|      1|  EMP_TEST_MACRO( EMP_PACK_TOP((a,b,c)), "a");
  274|      1|  EMP_TEST_MACRO( EMP_PACK_PUSH(x, (a,b,c)), "(x,a,b,c)");
  275|      1|  EMP_TEST_MACRO( EMP_PACK_SIZE((a,b,c)), "3");
  276|      1|
  277|      1|  // BAD TEST: EMP_TEST_MACRO( EMP_ARGS_TO_PACKS_1(4, a,b,c,d,e,f,g), "(a , b , c , d)" );
  278|      1|
  279|      1|
  280|      1|  EMP_TEST_MACRO( EMP_CALL_BY_PACKS(TST_, (Fixed), a,b,c,d,e,f,g,h,i,j,k,l,m), "TST_8((Fixed), a,b,c,d,e,f,g,h,i,j,k,l,m, ~) TST_4((Fixed), i,j,k,l,m, ~) TST_1((Fixed), m, ~)" );
  281|      1|
  282|      1|  // Make sure we can wrap each argument in a macro.
  283|      1|  EMP_TEST_MACRO( EMP_WRAP_EACH(EMP_DECORATE, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p), "[a] [b] [c] [d] [e] [f] [g] [h] [i] [j] [k] [l] [m] [n] [o] [p]" );
  284|      1|  EMP_TEST_MACRO( EMP_WRAP_EACH(EMP_DECORATE, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o), "[a] [b] [c] [d] [e] [f] [g] [h] [i] [j] [k] [l] [m] [n] [o]" );
  285|      1|  EMP_TEST_MACRO( EMP_WRAP_EACH(EMP_DECORATE, a, b, c, d, e, f, g, h, i, j, k, l, m), "[a] [b] [c] [d] [e] [f] [g] [h] [i] [j] [k] [l] [m]" );
  286|      1|
  287|      1|
  288|      1|  // Test replacement of commas
  289|      1|  EMP_TEST_MACRO( EMP_REPLACE_COMMAS(~, x,x,x,x,x,x,x), "x ~ x ~ x ~ x ~ x ~ x ~ x" );
  290|      1|  EMP_TEST_MACRO( EMP_REPLACE_COMMAS(%, x,x,x,x,x,x,x,x), "x % x % x % x % x % x % x % x" );
  291|      1|
  292|      1|
  293|      1|  // Simple argument manipulation
  294|      1|  EMP_TEST_MACRO( EMP_ROTATE_ARGS(a, b, c), "b, c, a" );
  295|      1|
  296|      1|  // Test trimming argument lists.
  297|      1|  EMP_TEST_MACRO( EMP_SELECT_ARGS( (i,x,i), a ), "a" );
  298|      1|  EMP_TEST_MACRO( EMP_SELECT_ARGS( (i,x,i), a,b ), "a" );
  299|      1|  EMP_TEST_MACRO( EMP_SELECT_ARGS( (i,x,i), a,b,c,d,e,f,g,h,i ), "a, c, d, f, g, i" );
  300|      1|  EMP_TEST_MACRO( EMP_SELECT_ARGS( (i,x), 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50 ), "1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49" );
  301|      1|
  302|      1|
  303|      1|  // Test more complex layouts...
  304|      1|  EMP_TEST_MACRO( EMP_LAYOUT(EMP_DECORATE, +, a, b, c, d, e, f, g, h), "[a] + [b] + [c] + [d] + [e] + [f] + [g] + [h]" );
  305|      1|  EMP_TEST_MACRO( EMP_WRAP_ARGS(EMP_DECORATE, a, b, c, d, e, f, g, h), "[a] , [b] , [c] , [d] , [e] , [f] , [g] , [h]" );
  306|      1|  EMP_TEST_MACRO( EMP_WRAP_ARG_PAIRS(EMP_DECORATE_PAIR, A, a, B, b, C, c, D, d, E, e, F, f), "[A-a], [B-b], [C-c], [D-d], [E-e], [F-f]" );
  307|      1|
  308|      1|
  309|      1|  // Rest controlling argument number.
  310|      1|  EMP_TEST_MACRO( EMP_DUPLICATE_ARGS(15, x), "x, x, x, x, x, x, x, x, x, x, x, x, x, x, x" );
  311|      1|  EMP_TEST_MACRO( EMP_DUPLICATE_ARGS(5, x,y,z), "x,y,z, x,y,z, x,y,z, x,y,z, x,y,z" );
  312|      1|  EMP_TEST_MACRO( EMP_DUPLICATE_ARGS(63, 123), "123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123, 123" );
  313|      1|
  314|      1|  EMP_TEST_MACRO( EMP_CROP_ARGS_TO(26, x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x,x),
  315|      1|                  "x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x , x" );
  316|      1|
  317|      1|  EMP_TEST_MACRO( EMP_CROP_ARGS_TO(5, a, b, c, d, e, f, g, h, i, j), "a , b , c , d , e" );
  318|      1|  EMP_TEST_MACRO( EMP_CROP_ARGS_TO(4, a, b, c, d, e, f, g, h, i, j), "a , b , c , d" );
  319|      1|  EMP_TEST_MACRO( EMP_CROP_ARGS_TO(4, a, b, c, d), "a , b , c , d" );
  320|      1|
  321|      1|  EMP_TEST_MACRO( EMP_FORCE_ARGS_TO(3, x, a, b, c, d), "a , b , c" );
  322|      1|  EMP_TEST_MACRO( EMP_FORCE_ARGS_TO(4, x, a, b, c, d), "a , b , c , d" );
  323|      1|  EMP_TEST_MACRO( EMP_FORCE_ARGS_TO(7, x, a, b, c, d), "a , b , c , d , x , x , x" );
  324|      1|
  325|      1|  // Test collect only-odd or only-even arguments.
  326|      1|  EMP_TEST_MACRO( EMP_GET_ODD_ARGS(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), "1, 3, 5, 7, 9, 11");
  327|      1|  EMP_TEST_MACRO( EMP_GET_EVEN_ARGS(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), "2, 4, 6, 8, 10, 12");
  328|      1|  EMP_TEST_MACRO( EMP_GET_ODD_ARGS(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13), "1, 3, 5, 7, 9, 11, 13");
  329|      1|  EMP_TEST_MACRO( EMP_GET_EVEN_ARGS(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13), "2, 4, 6, 8, 10, 12");
  330|      1|
  331|      1|
  332|      1|  EMP_TEST_MACRO( EMP_REVERSE_ARGS(a,b,c, d), "d, c, b, a" );
  333|      1|  EMP_TEST_MACRO( EMP_TYPES_TO_ARGS(int, char, bool, std::string),
  334|      1|                  "int arg1, char arg2, bool arg3, std::string arg4" );
  335|      1|
  336|      1|
  337|      1|  // Test EMP_STRINGIFY_EACH
  338|      1|  std::array<std::string, 2> test = {{ EMP_STRINGIFY_EACH(some, words) }};
  339|      1|  std::array<std::string, 9> test9 =
  340|      1|    {{ EMP_STRINGIFY_EACH(one, two, three, four, five, six, seven, eight, nine) }};
  341|      1|
  342|      1|  REQUIRE(test.size() == 2);
  343|      1|  REQUIRE(test[0] == "some");
  344|      1|  REQUIRE(test[1] == "words");
  345|      1|  REQUIRE(test9.size() == 9);
  346|      1|  REQUIRE(test9[4] == "five");
  347|      1|  REQUIRE(test9[7] == "eight");
  348|      1|
  349|      1|  EMP_TEST_MACRO( EMP_STRINGIFY_EACH(some, words), "\"some\" , \"words\"" );
  350|      1|}
  351|       |
  352|       |
  353|       |TEST_CASE("Test errors", "[tools]")
  354|      1|{
  355|      1|  emp::TriggerExcept("test_fail", "The test failed.  *sob*");
  356|      1|  emp::TriggerExcept("test_fail2", "The second test failed too.  But it's not quite as aweful.", false);
  357|      1|  emp::TriggerExcept("test_fail2", "The third test is just test 2 again, but worse", true);
  358|      1|
  359|      1|  REQUIRE( emp::CountExcepts() == 3 );
  360|      1|  auto except = emp::PopExcept("test_fail2");
  361|      1|  REQUIRE( emp::CountExcepts() == 2 );
  362|      1|  REQUIRE( except.desc == "The second test failed too.  But it's not quite as aweful." );
  363|      1|  REQUIRE( emp::HasExcept("test_fail2") == true );
  364|      1|  REQUIRE( emp::HasExcept("test_fail3") == false );
  365|      1|  emp::ClearExcepts();
  366|      1|  REQUIRE( emp::CountExcepts() == 0 );
  367|      1|}
  368|       |
  369|       |
  370|       |TEST_CASE("Test Ptr", "[base]")
  371|      1|{
  372|      1|  // Test default constructor.
  373|      1|  emp::Ptr<int> ptr1;
  374|      1|  ptr1.New();
  375|      1|  *ptr1 = 5;
  376|      1|  REQUIRE(*ptr1 == 5);
  377|      1|  ptr1.Delete();
  378|      1|
  379|      1|  // Test pointer constructor
  380|      1|  int * temp_int = new int;
  381|      1|  emp::Ptr<int> ptr2(temp_int, true);
  382|      1|  *ptr2 = 10;
  383|      1|  REQUIRE(*ptr2 == 10);
  384|      1|  ptr2.Delete();
  385|      1|
  386|      1|  // Test non-pointer object constructor
  387|      1|  int base_val = 15;
  388|      1|  emp::Ptr<int> ptr3(&base_val);
  389|      1|  REQUIRE(*ptr3 == 15);
  390|      1|  base_val = 20;                 // Make sure pointed to value changes with original variable.
  391|      1|  REQUIRE(*ptr3 == 20);
  392|      1|
  393|      1|  // Test copy-constructor.
  394|      1|  emp::Ptr<int> ptr4(ptr3);
  395|      1|  REQUIRE(*ptr4 == 20);
  396|      1|  *ptr4 = 25;                    // Change this new pointer...
  397|      1|  REQUIRE(*ptr4 == 25);       // ...make sure it actually changed.
  398|      1|  REQUIRE(*ptr3 == 25);       // ...make sure the other pointer reflects the change.
  399|      1|  REQUIRE(base_val == 25);    // ...make sure the original variable changed.
  400|      1|
  401|      1|  // -- Test count tracking on emp::Ptr --
  402|      1|  // A bit of an odd set of test... we need to create and destory pointers to make sure
  403|      1|  // that all of the counts are correct, so we're going to use arrays of pointers to them.
  404|      1|
  405|      1|  emp::vector<emp::Ptr<char> *> ptr_set(10);
  406|      1|  ptr_set[0] = new emp::Ptr<char>;
  407|      1|  ptr_set[0]->New(42);
  408|     10|  for (size_t i = 1; i < 10; i++) ptr_set[i] = new emp::Ptr<char>(*(ptr_set[0]));
  409|      1|
  410|      1|  // Do we have a proper count of 10?
  411|      1|  #ifdef EMP_TRACK_MEM
  412|      1|  REQUIRE(ptr_set[0]->DebugGetCount() == 10);
  413|      1|  ptr_set[1]->New(91);
  414|      1|  REQUIRE(ptr_set[0]->DebugGetCount() == 9);
  415|      1|  *(ptr_set[2]) = *(ptr_set[1]);
  416|      1|  REQUIRE(ptr_set[0]->DebugGetCount() == 8);
  417|      1|  REQUIRE(ptr_set[1]->DebugGetCount() == 2);
  418|      1|
  419|      1|  ptr_set[3]->Delete();
  420|      1|  ptr_set[1]->Delete();
  421|      1|  #endif
  422|      1|
  423|      1|  // Make sure that we are properly handling temporary pointers moved to uninitialized pointes.
  424|      1|  // (Previously breaking, now fixed.)
  425|      1|  int a = 9;
  426|      1|  emp::Ptr<int> ptr_a;
  427|      1|  ptr_a = emp::ToPtr(&a);
  428|      1|  int a_val = *(ptr_a);
  429|      1|  REQUIRE(a_val == 9);
  430|      1|
  431|      1|
  432|      1|  // std::cout << ptr_set[0]->DebugGetCount() << std::endl;
  433|      1|
  434|      1|//   // @CAO Make sure we don't delete below 0
  435|      1|//   // @CAO Make sure we don't delete below 1 if we own it
  436|      1|//   // @CAO Make sure we only delete if you own it
  437|      1|//   // @CAO Make sure not to delete twice!
  438|      1|//   // @CAO Make sure we don't add (as owner) a pointer we already own
  439|      1|//
  440|      1|//   // -- Do some direct tests on pointer trackers --
  441|      1|//
  442|      1|//   int * real_ptr1 = new int(1);  // Count of 2 in tracker
  443|      1|//   int * real_ptr2 = new int(2);  // Deleted in tracker
  444|      1|//   int * real_ptr3 = new int(3);  // Unknown to tracker
  445|      1|//   int * real_ptr4 = new int(4);  // Passively known to tracker (marked non-owner)
  446|      1|//   auto & tracker = emp::PtrTracker::Get();
  447|      1|//
  448|      1|//   tracker.New(real_ptr1);
  449|      1|//   tracker.Inc(real_ptr1);
  450|      1|//   tracker.Inc(real_ptr1);
  451|      1|//   tracker.Dec(real_ptr1);
  452|      1|//
  453|      1|//   tracker.New(real_ptr2);
  454|      1|//   tracker.MarkDeleted(real_ptr2);
  455|      1|//
  456|      1|//   tracker.Old(real_ptr4);
  457|      1|//
  458|      1|//   REQUIRE(tracker.HasPtr(real_ptr1) == true);
  459|      1|//   REQUIRE(tracker.HasPtr(real_ptr2) == true);
  460|      1|// //  REQUIRE(tracker.HasPtr(real_ptr3) == false);  // Technically may be previous pointer re-used!
  461|      1|//   REQUIRE(tracker.HasPtr(real_ptr4) == true);
  462|      1|//
  463|      1|//   REQUIRE(tracker.IsActive(real_ptr1) == true);
  464|      1|//   REQUIRE(tracker.IsActive(real_ptr2) == false);
  465|      1|// //  REQUIRE(tracker.IsActive(real_ptr3) == false);
  466|      1|//   REQUIRE(tracker.IsActive(real_ptr4) == true);
  467|      1|//
  468|      1|//   REQUIRE(tracker.IsOwner(real_ptr1) == true);
  469|      1|//   REQUIRE(tracker.IsOwner(real_ptr2) == true);
  470|      1|// //  REQUIRE(tracker.IsOwner(real_ptr3) == false);
  471|      1|//   REQUIRE(tracker.IsOwner(real_ptr4) == false);
  472|      1|//
  473|      1|//   REQUIRE(tracker.GetCount(real_ptr1) == 2);
  474|      1|//   REQUIRE(tracker.GetCount(real_ptr2) == 1);
  475|      1|// //  REQUIRE(tracker.GetCount(real_ptr3) == 0);
  476|      1|//   REQUIRE(tracker.GetCount(real_ptr4) == 1);
  477|      1|}
  478|       |
  479|       |
  480|       |TEST_CASE("Test vector", "[base]")
  481|      1|{
  482|      1|  emp::vector<int> v(20);
  483|      1|
  484|     21|  for (size_t i = 0; i < 20; i++) {
  485|     20|    v[i] = (int) (i * i);
  486|     20|  }
  487|      1|
  488|      1|  int total = 0;
  489|     20|  for (int i : v) total += i;
  490|      1|
  491|      1|  REQUIRE(total == 2470);
  492|      1|
  493|      1|  // Examine vector<bool> specialization.
  494|      1|  emp::vector<bool> vb(1000,false);
  495|  1.00k|  for (size_t i = 0; i < vb.size(); i++) {
  496|  1.00k|    if (i%3==0 || i%5 == 0) vb[i] = true;
  497|  1.00k|  }
  498|      1|  size_t count = 0;
  499|      1|  const auto vb2 = vb;
  500|  1.00k|  for (size_t i = 0; i < vb.size(); i++) {
  501|  1.00k|    if (vb2[i]) count++;
  502|  1.00k|  }
  503|      1|
  504|      1|  REQUIRE(count == 467);
  505|      1|}
  506|       |
  507|      1|TEST_CASE("Replicate ptr bug", "[ptr]") {
  508|      1|  struct testA {
  509|      1|    int a = 9;
  510|      1|    emp::Ptr<int> GetA() {return emp::ToPtr(&a);}
  511|      1|  };
  512|      1|
  513|      1|  struct testB {
  514|      1|    std::function<emp::Ptr<int>(void)> b_fun;
  515|      1|    emp::Ptr<int> b;
  516|      1|
  517|      1|    void SetBFun(std::function<emp::Ptr<int>(void)> fun) {
  518|      1|      b_fun = fun;
  519|      1|    }
  520|      1|
  521|      1|    void RunBFun() {
  522|      1|      b = b_fun();
  523|      1|    }
  524|      1|
  525|      1|  };
  526|      1|
  527|      1|  testA ta;
  528|      1|  testB tb;
  529|      1|
  530|      1|  std::function<emp::Ptr<int>(void)> return_a = [&ta](){return ta.GetA();};
  531|      1|  tb.SetBFun(return_a);
  532|      1|  tb.RunBFun();
  533|      1|  REQUIRE(*(tb.b) == 9);
  534|      1|
  535|      1|}

